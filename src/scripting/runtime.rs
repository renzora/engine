//! Script runtime - executes scripts and applies their commands

use bevy::prelude::*;

use super::{
    ScriptCommand, ScriptComponent, ScriptContext, ScriptInput, ScriptRegistry,
    ScriptTime, ScriptTransform, RhaiScriptEngine, RhaiScriptContext, ChildNodeInfo,
};
use crate::core::{EditorEntity, SceneNode, WorldEnvironmentMarker};
use crate::project::CurrentProject;

/// System that runs all scripts
pub fn run_scripts(
    mut commands: Commands,
    time: Res<Time>,
    input: Res<ScriptInput>,
    registry: Res<ScriptRegistry>,
    mut scripts: Query<(Entity, &mut ScriptComponent, &mut Transform)>,
    frame_count: Local<u64>,
) {
    let script_time = ScriptTime {
        elapsed: time.elapsed_secs_f64(),
        delta: time.delta_secs(),
        fixed_delta: 1.0 / 60.0,
        frame_count: *frame_count,
    };

    for (entity, mut script_comp, mut transform) in scripts.iter_mut() {
        if !script_comp.enabled {
            continue;
        }

        // Get the script from registry
        let Some(script) = registry.get(&script_comp.script_id) else {
            continue;
        };

        // Create context
        let script_transform = ScriptTransform::from_transform(&transform);
        let mut ctx = ScriptContext::new(entity, script_transform, script_time, &input);

        // Call on_ready if not initialized
        if !script_comp.runtime_state.initialized {
            script.on_ready(&mut ctx, &script_comp.variables);
            script_comp.runtime_state.initialized = true;
        }

        // Call on_update
        script.on_update(&mut ctx, &script_comp.variables);

        // Apply commands
        let script_commands = ctx.take_commands();
        apply_script_commands(&mut commands, &mut transform, &script_commands);

        script_comp.runtime_state.last_frame = *frame_count;
    }
}

/// Apply commands generated by a script
fn apply_script_commands(
    commands: &mut Commands,
    transform: &mut Transform,
    script_commands: &[ScriptCommand],
) {
    for cmd in script_commands {
        match cmd {
            ScriptCommand::Translate { delta, .. } => {
                transform.translation += *delta;
            }
            ScriptCommand::SetPosition { position, .. } => {
                transform.translation = *position;
            }
            ScriptCommand::Rotate { rotation, .. } => {
                transform.rotation = *rotation * transform.rotation;
            }
            ScriptCommand::SetRotation { rotation, .. } => {
                transform.rotation = *rotation;
            }
            ScriptCommand::LookAt { target, .. } => {
                transform.look_at(*target, Vec3::Y);
            }
            ScriptCommand::SetScale { scale, .. } => {
                transform.scale = *scale;
            }
            ScriptCommand::Print { message } => {
                info!("[Script] {}", message);
            }
            ScriptCommand::Spawn { name } => {
                commands.spawn((
                    Transform::default(),
                    Visibility::default(),
                    EditorEntity { name: name.clone() },
                    SceneNode,
                ));
            }
            ScriptCommand::Destroy { entity } => {
                commands.entity(*entity).despawn();
            }
        }
    }
}

/// Pending parent/child transform changes
struct TransformChange {
    new_position: Option<Vec3>,
    new_rotation: Option<Vec3>,
    translation: Option<Vec3>,
}

/// System that runs Rhai file-based scripts
pub fn run_rhai_scripts(
    time: Res<Time>,
    input: Res<ScriptInput>,
    rhai_engine: Res<RhaiScriptEngine>,
    current_project: Option<Res<CurrentProject>>,
    mut scripts: Query<(Entity, &mut ScriptComponent, &mut Transform, Option<&ChildOf>, Option<&Children>)>,
    mut all_transforms: Query<&mut Transform, Without<ScriptComponent>>,
    editor_entities: Query<&EditorEntity>,
    mut world_environments: Query<&mut WorldEnvironmentMarker>,
) {
    use std::collections::HashMap;

    let Some(_project) = current_project else {
        return;
    };

    let script_time = ScriptTime {
        elapsed: time.elapsed_secs_f64(),
        delta: time.delta_secs(),
        fixed_delta: 1.0 / 60.0,
        frame_count: 0,
    };

    // Collect parent and child changes to apply after the main loop
    let mut parent_changes: HashMap<Entity, TransformChange> = HashMap::new();
    let mut child_changes: HashMap<Entity, TransformChange> = HashMap::new();

    for (entity, mut script_comp, mut transform, parent_ref, children_ref) in scripts.iter_mut() {
        if !script_comp.enabled {
            continue;
        }

        // Only process file-based scripts
        let Some(script_path) = &script_comp.script_path else {
            continue;
        };

        // Load/reload the script
        let Ok(compiled) = rhai_engine.load_script(script_path) else {
            continue;
        };

        // Create Rhai context
        let script_transform = ScriptTransform::from_transform(&transform);
        let mut ctx = RhaiScriptContext::new(script_time, script_transform);
        ctx.input_movement = input.get_movement_vector();
        ctx.mouse_position = input.mouse_position;
        ctx.mouse_delta = input.mouse_delta;

        // Gamepad input (using gamepad 0)
        ctx.gamepad_left_stick = Vec2::new(
            input.get_gamepad_left_stick_x(0),
            input.get_gamepad_left_stick_y(0),
        );
        ctx.gamepad_right_stick = Vec2::new(
            input.get_gamepad_right_stick_x(0),
            input.get_gamepad_right_stick_y(0),
        );
        ctx.gamepad_left_trigger = input.get_gamepad_left_trigger(0);
        ctx.gamepad_right_trigger = input.get_gamepad_right_trigger(0);
        // Map common buttons
        use bevy::input::gamepad::GamepadButton;
        ctx.gamepad_buttons[0] = input.is_gamepad_button_pressed(0, GamepadButton::South); // A
        ctx.gamepad_buttons[1] = input.is_gamepad_button_pressed(0, GamepadButton::East);  // B
        ctx.gamepad_buttons[2] = input.is_gamepad_button_pressed(0, GamepadButton::West);  // X
        ctx.gamepad_buttons[3] = input.is_gamepad_button_pressed(0, GamepadButton::North); // Y
        ctx.gamepad_buttons[4] = input.is_gamepad_button_pressed(0, GamepadButton::LeftTrigger);  // LB
        ctx.gamepad_buttons[5] = input.is_gamepad_button_pressed(0, GamepadButton::RightTrigger); // RB
        ctx.gamepad_buttons[6] = input.is_gamepad_button_pressed(0, GamepadButton::Select);
        ctx.gamepad_buttons[7] = input.is_gamepad_button_pressed(0, GamepadButton::Start);
        ctx.gamepad_buttons[8] = input.is_gamepad_button_pressed(0, GamepadButton::LeftThumb);  // L3
        ctx.gamepad_buttons[9] = input.is_gamepad_button_pressed(0, GamepadButton::RightThumb); // R3
        ctx.gamepad_buttons[10] = input.is_gamepad_button_pressed(0, GamepadButton::DPadUp);
        ctx.gamepad_buttons[11] = input.is_gamepad_button_pressed(0, GamepadButton::DPadDown);
        ctx.gamepad_buttons[12] = input.is_gamepad_button_pressed(0, GamepadButton::DPadLeft);
        ctx.gamepad_buttons[13] = input.is_gamepad_button_pressed(0, GamepadButton::DPadRight);

        // Get parent info if available
        if let Some(child_of) = parent_ref {
            ctx.has_parent = true;
            ctx.parent_entity = Some(child_of.0);
            if let Ok(parent_transform) = all_transforms.get(child_of.0) {
                ctx.parent_position = parent_transform.translation;
                let (x, y, z) = parent_transform.rotation.to_euler(EulerRot::XYZ);
                ctx.parent_rotation = Vec3::new(
                    x.to_degrees(),
                    y.to_degrees(),
                    z.to_degrees(),
                );
                ctx.parent_scale = parent_transform.scale;
            }
        }

        // Get children info if available - build name to entity mapping
        let mut child_name_to_entity: HashMap<String, Entity> = HashMap::new();
        if let Some(children) = children_ref {
            for child_entity in children.iter() {
                if let Ok(child_transform) = all_transforms.get(child_entity) {
                    let child_name = editor_entities
                        .get(child_entity)
                        .map(|e| e.name.clone())
                        .unwrap_or_else(|_| format!("Entity_{}", child_entity.index()));

                    let (rx, ry, rz) = child_transform.rotation.to_euler(EulerRot::XYZ);
                    ctx.children.push(ChildNodeInfo {
                        entity: child_entity,
                        name: child_name.clone(),
                        position: child_transform.translation,
                        rotation: Vec3::new(rx.to_degrees(), ry.to_degrees(), rz.to_degrees()),
                        scale: child_transform.scale,
                    });
                    child_name_to_entity.insert(child_name, child_entity);
                }
            }
        }

        // Call on_ready if not initialized
        if !script_comp.runtime_state.initialized {
            rhai_engine.call_on_ready(&compiled, &mut ctx, &script_comp.variables);
            script_comp.runtime_state.initialized = true;
        }

        // Call on_update
        rhai_engine.call_on_update(&compiled, &mut ctx, &script_comp.variables);

        // Apply transform results to self
        if let Some(pos) = ctx.new_position {
            transform.translation = pos;
        }

        if let Some(rot) = ctx.new_rotation {
            transform.rotation = Quat::from_euler(
                EulerRot::XYZ,
                rot.x.to_radians(),
                rot.y.to_radians(),
                rot.z.to_radians(),
            );
        }

        if let Some(delta) = ctx.translation {
            if delta.length_squared() > 0.0001 {
                info!("[Rhai] Translating by {:?}", delta);
            }
            transform.translation += delta;
        }

        if let Some(msg) = ctx.print_message {
            info!("[Rhai] {}", msg);
        }

        // Collect parent transform changes
        if let Some(parent_entity) = ctx.parent_entity {
            let has_parent_changes = ctx.parent_new_position.is_some()
                || ctx.parent_new_rotation.is_some()
                || ctx.parent_translation.is_some();

            if has_parent_changes {
                parent_changes.insert(parent_entity, TransformChange {
                    new_position: ctx.parent_new_position,
                    new_rotation: ctx.parent_new_rotation,
                    translation: ctx.parent_translation,
                });
            }
        }

        // Collect child transform changes
        for (child_name, change) in &ctx.child_changes {
            if let Some(&child_entity) = child_name_to_entity.get(child_name) {
                child_changes.insert(child_entity, TransformChange {
                    new_position: change.new_position,
                    new_rotation: change.new_rotation,
                    translation: change.translation,
                });
            }
        }

        // Apply environment changes (to all WorldEnvironmentMarker entities)
        let has_env_changes = ctx.env_sun_azimuth.is_some()
            || ctx.env_sun_elevation.is_some()
            || ctx.env_ambient_brightness.is_some()
            || ctx.env_ambient_color.is_some()
            || ctx.env_sky_top_color.is_some()
            || ctx.env_sky_horizon_color.is_some()
            || ctx.env_fog_enabled.is_some()
            || ctx.env_fog_color.is_some()
            || ctx.env_fog_start.is_some()
            || ctx.env_fog_end.is_some()
            || ctx.env_exposure.is_some();

        if has_env_changes {
            for mut world_env in world_environments.iter_mut() {
                if let Some(azimuth) = ctx.env_sun_azimuth {
                    world_env.data.procedural_sky.sun_angle_azimuth = azimuth;
                }
                if let Some(elevation) = ctx.env_sun_elevation {
                    world_env.data.procedural_sky.sun_angle_elevation = elevation;
                }
                if let Some(brightness) = ctx.env_ambient_brightness {
                    world_env.data.ambient_brightness = brightness;
                }
                if let Some((r, g, b)) = ctx.env_ambient_color {
                    world_env.data.ambient_color = (r, g, b);
                }
                if let Some((r, g, b)) = ctx.env_sky_top_color {
                    world_env.data.procedural_sky.sky_top_color = (r, g, b);
                }
                if let Some((r, g, b)) = ctx.env_sky_horizon_color {
                    world_env.data.procedural_sky.sky_horizon_color = (r, g, b);
                }
                if let Some(enabled) = ctx.env_fog_enabled {
                    world_env.data.fog_enabled = enabled;
                }
                if let Some((r, g, b)) = ctx.env_fog_color {
                    world_env.data.fog_color = (r, g, b);
                }
                if let Some(start) = ctx.env_fog_start {
                    world_env.data.fog_start = start;
                }
                if let Some(end) = ctx.env_fog_end {
                    world_env.data.fog_end = end;
                }
                if let Some(exposure) = ctx.env_exposure {
                    world_env.data.exposure = exposure;
                }
            }
        }
    }

    // Apply collected parent changes
    for (parent_entity, change) in parent_changes {
        if let Ok(mut parent_transform) = all_transforms.get_mut(parent_entity) {
            if let Some(pos) = change.new_position {
                parent_transform.translation = pos;
            }
            if let Some(rot) = change.new_rotation {
                parent_transform.rotation = Quat::from_euler(
                    EulerRot::XYZ,
                    rot.x.to_radians(),
                    rot.y.to_radians(),
                    rot.z.to_radians(),
                );
            }
            if let Some(delta) = change.translation {
                parent_transform.translation += delta;
            }
        }
    }

    // Apply collected child changes
    for (child_entity, change) in child_changes {
        if let Ok(mut child_transform) = all_transforms.get_mut(child_entity) {
            if let Some(pos) = change.new_position {
                child_transform.translation = pos;
            }
            if let Some(rot) = change.new_rotation {
                child_transform.rotation = Quat::from_euler(
                    EulerRot::XYZ,
                    rot.x.to_radians(),
                    rot.y.to_radians(),
                    rot.z.to_radians(),
                );
            }
            if let Some(delta) = change.translation {
                child_transform.translation += delta;
            }
        }
    }
}
