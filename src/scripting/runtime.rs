//! Script runtime - executes scripts and applies their commands

use bevy::prelude::*;

use super::{
    ScriptCommand, ScriptComponent, ScriptContext, ScriptInput, ScriptRegistry,
    ScriptTime, ScriptTransform, RhaiScriptEngine, RhaiScriptContext, ChildNodeInfo,
    RhaiCommand,
};
use crate::core::{EditorEntity, SceneNode, WorldEnvironmentMarker, PlayModeState};
use crate::core::resources::console::{console_log, LogLevel};
use crate::project::CurrentProject;

/// System that runs all scripts
pub fn run_scripts(
    mut commands: Commands,
    time: Res<Time>,
    input: Res<ScriptInput>,
    registry: Res<ScriptRegistry>,
    play_mode: Res<PlayModeState>,
    mut scripts: Query<(Entity, &mut ScriptComponent, &mut Transform)>,
    frame_count: Local<u64>,
) {
    // Only run scripts during play mode
    if !play_mode.is_playing() {
        return;
    }

    let script_time = ScriptTime {
        elapsed: time.elapsed_secs_f64(),
        delta: time.delta_secs(),
        fixed_delta: 1.0 / 60.0,
        frame_count: *frame_count,
    };

    for (entity, mut script_comp, mut transform) in scripts.iter_mut() {
        if !script_comp.enabled {
            continue;
        }

        // Get the script from registry
        let Some(script) = registry.get(&script_comp.script_id) else {
            continue;
        };

        // Create context
        let script_transform = ScriptTransform::from_transform(&transform);
        let mut ctx = ScriptContext::new(entity, script_transform, script_time, &input);

        // Call on_ready if not initialized
        if !script_comp.runtime_state.initialized {
            script.on_ready(&mut ctx, &script_comp.variables);
            script_comp.runtime_state.initialized = true;
        }

        // Call on_update
        script.on_update(&mut ctx, &script_comp.variables);

        // Apply commands
        let script_commands = ctx.take_commands();
        apply_script_commands(&mut commands, &mut transform, &script_commands);

        script_comp.runtime_state.last_frame = *frame_count;
    }
}

/// Apply commands generated by a script
fn apply_script_commands(
    commands: &mut Commands,
    transform: &mut Transform,
    script_commands: &[ScriptCommand],
) {
    for cmd in script_commands {
        match cmd {
            ScriptCommand::Translate { delta, .. } => {
                transform.translation += *delta;
            }
            ScriptCommand::SetPosition { position, .. } => {
                transform.translation = *position;
            }
            ScriptCommand::Rotate { rotation, .. } => {
                transform.rotation = *rotation * transform.rotation;
            }
            ScriptCommand::SetRotation { rotation, .. } => {
                transform.rotation = *rotation;
            }
            ScriptCommand::LookAt { target, .. } => {
                transform.look_at(*target, Vec3::Y);
            }
            ScriptCommand::SetScale { scale, .. } => {
                transform.scale = *scale;
            }
            ScriptCommand::Print { message } => {
                info!("[Script] {}", message);
            }
            ScriptCommand::Spawn { name } => {
                commands.spawn((
                    Transform::default(),
                    Visibility::default(),
                    EditorEntity {
                        name: name.clone(),
                        tag: String::new(),
                        visible: true,
                        locked: false,
                    },
                    SceneNode,
                ));
            }
            ScriptCommand::Destroy { entity } => {
                commands.entity(*entity).despawn();
            }
        }
    }
}

/// Pending parent/child transform changes
struct TransformChange {
    new_position: Option<Vec3>,
    new_rotation: Option<Vec3>,
    translation: Option<Vec3>,
}

/// System that runs Rhai file-based scripts
pub fn run_rhai_scripts(
    mut commands: Commands,
    time: Res<Time>,
    input: Res<ScriptInput>,
    rhai_engine: Res<RhaiScriptEngine>,
    current_project: Option<Res<CurrentProject>>,
    play_mode: Res<PlayModeState>,
    mut scripts: Query<(Entity, &mut ScriptComponent, &mut Transform, Option<&ChildOf>, Option<&Children>)>,
    mut all_transforms: Query<&mut Transform, Without<ScriptComponent>>,
    editor_entities: Query<&EditorEntity>,
    mut world_environments: Query<&mut WorldEnvironmentMarker>,
    mut visibility_query: Query<&mut Visibility>,
) {
    use std::collections::HashMap;

    // Only run scripts during play mode
    if !play_mode.is_playing() {
        return;
    }

    let Some(_project) = current_project else {
        return;
    };

    let script_time = ScriptTime {
        elapsed: time.elapsed_secs_f64(),
        delta: time.delta_secs(),
        fixed_delta: 1.0 / 60.0,
        frame_count: 0,
    };

    // Collect parent and child changes to apply after the main loop
    let mut parent_changes: HashMap<Entity, TransformChange> = HashMap::new();
    let mut child_changes: HashMap<Entity, TransformChange> = HashMap::new();
    // Collect all Rhai commands to process after the main loop
    let mut all_rhai_commands: Vec<(Entity, RhaiCommand)> = Vec::new();

    for (entity, mut script_comp, mut transform, parent_ref, children_ref) in scripts.iter_mut() {
        if !script_comp.enabled {
            continue;
        }

        // Only process file-based scripts
        let Some(script_path) = &script_comp.script_path else {
            continue;
        };

        // Load/reload the script (supports both .rhai and .blueprint files)
        let compiled = match rhai_engine.load_script_file(script_path) {
            Ok(c) => {
                // Clear any previous error state
                if script_comp.runtime_state.has_error {
                    console_log(LogLevel::Success, "Script", format!("'{}' loaded successfully", c.name));
                    script_comp.runtime_state.has_error = false;
                }
                c
            }
            Err(_e) => {
                // Error already logged by load_script_file, just mark error state
                script_comp.runtime_state.has_error = true;
                continue;
            }
        };

        // Create Rhai context
        let script_transform = ScriptTransform::from_transform(&transform);
        let mut ctx = RhaiScriptContext::new(script_time, script_transform);

        // Set self entity info
        ctx.self_entity_id = entity.to_bits();
        ctx.self_entity_name = editor_entities
            .get(entity)
            .map(|e| e.name.clone())
            .unwrap_or_else(|_| format!("Entity_{}", entity.index()));

        ctx.input_movement = input.get_movement_vector();
        ctx.mouse_position = input.mouse_position;
        ctx.mouse_delta = input.mouse_delta;

        // Gamepad input (using gamepad 0)
        ctx.gamepad_left_stick = Vec2::new(
            input.get_gamepad_left_stick_x(0),
            input.get_gamepad_left_stick_y(0),
        );
        ctx.gamepad_right_stick = Vec2::new(
            input.get_gamepad_right_stick_x(0),
            input.get_gamepad_right_stick_y(0),
        );
        ctx.gamepad_left_trigger = input.get_gamepad_left_trigger(0);
        ctx.gamepad_right_trigger = input.get_gamepad_right_trigger(0);
        // Map common buttons
        use bevy::input::gamepad::GamepadButton;
        ctx.gamepad_buttons[0] = input.is_gamepad_button_pressed(0, GamepadButton::South); // A
        ctx.gamepad_buttons[1] = input.is_gamepad_button_pressed(0, GamepadButton::East);  // B
        ctx.gamepad_buttons[2] = input.is_gamepad_button_pressed(0, GamepadButton::West);  // X
        ctx.gamepad_buttons[3] = input.is_gamepad_button_pressed(0, GamepadButton::North); // Y
        ctx.gamepad_buttons[4] = input.is_gamepad_button_pressed(0, GamepadButton::LeftTrigger);  // LB
        ctx.gamepad_buttons[5] = input.is_gamepad_button_pressed(0, GamepadButton::RightTrigger); // RB
        ctx.gamepad_buttons[6] = input.is_gamepad_button_pressed(0, GamepadButton::Select);
        ctx.gamepad_buttons[7] = input.is_gamepad_button_pressed(0, GamepadButton::Start);
        ctx.gamepad_buttons[8] = input.is_gamepad_button_pressed(0, GamepadButton::LeftThumb);  // L3
        ctx.gamepad_buttons[9] = input.is_gamepad_button_pressed(0, GamepadButton::RightThumb); // R3
        ctx.gamepad_buttons[10] = input.is_gamepad_button_pressed(0, GamepadButton::DPadUp);
        ctx.gamepad_buttons[11] = input.is_gamepad_button_pressed(0, GamepadButton::DPadDown);
        ctx.gamepad_buttons[12] = input.is_gamepad_button_pressed(0, GamepadButton::DPadLeft);
        ctx.gamepad_buttons[13] = input.is_gamepad_button_pressed(0, GamepadButton::DPadRight);

        // Get parent info if available
        if let Some(child_of) = parent_ref {
            ctx.has_parent = true;
            ctx.parent_entity = Some(child_of.0);
            if let Ok(parent_transform) = all_transforms.get(child_of.0) {
                ctx.parent_position = parent_transform.translation;
                let (x, y, z) = parent_transform.rotation.to_euler(EulerRot::XYZ);
                ctx.parent_rotation = Vec3::new(
                    x.to_degrees(),
                    y.to_degrees(),
                    z.to_degrees(),
                );
                ctx.parent_scale = parent_transform.scale;
            }
        }

        // Get children info if available - build name to entity mapping
        let mut child_name_to_entity: HashMap<String, Entity> = HashMap::new();
        if let Some(children) = children_ref {
            for child_entity in children.iter() {
                if let Ok(child_transform) = all_transforms.get(child_entity) {
                    let child_name = editor_entities
                        .get(child_entity)
                        .map(|e| e.name.clone())
                        .unwrap_or_else(|_| format!("Entity_{}", child_entity.index()));

                    let (rx, ry, rz) = child_transform.rotation.to_euler(EulerRot::XYZ);
                    ctx.children.push(ChildNodeInfo {
                        entity: child_entity,
                        name: child_name.clone(),
                        position: child_transform.translation,
                        rotation: Vec3::new(rx.to_degrees(), ry.to_degrees(), rz.to_degrees()),
                        scale: child_transform.scale,
                    });
                    child_name_to_entity.insert(child_name, child_entity);
                }
            }
        }

        // Call on_ready if not initialized
        if !script_comp.runtime_state.initialized {
            console_log(LogLevel::Info, "Script", format!("Initializing '{}'", compiled.name));
            rhai_engine.call_on_ready(&compiled, &mut ctx, &script_comp.variables);
            script_comp.runtime_state.initialized = true;
        }

        // Call on_update
        rhai_engine.call_on_update(&compiled, &mut ctx, &script_comp.variables);

        // Apply transform results to self
        if let Some(pos) = ctx.new_position {
            transform.translation = pos;
        }

        if let Some(rot) = ctx.new_rotation {
            transform.rotation = Quat::from_euler(
                EulerRot::XYZ,
                rot.x.to_radians(),
                rot.y.to_radians(),
                rot.z.to_radians(),
            );
        }

        // Apply rotation delta (degrees per frame)
        if let Some(rot_delta) = ctx.rotation_delta {
            let delta_quat = Quat::from_euler(
                EulerRot::XYZ,
                rot_delta.x.to_radians(),
                rot_delta.y.to_radians(),
                rot_delta.z.to_radians(),
            );
            transform.rotation = delta_quat * transform.rotation;
        }

        if let Some(delta) = ctx.translation {
            if delta.length_squared() > 0.0001 {
                info!("[Rhai] Translating by {:?}", delta);
            }
            transform.translation += delta;
        }

        if let Some(msg) = ctx.print_message {
            console_log(LogLevel::Info, "Script", msg);
        }

        // Collect parent transform changes
        if let Some(parent_entity) = ctx.parent_entity {
            let has_parent_changes = ctx.parent_new_position.is_some()
                || ctx.parent_new_rotation.is_some()
                || ctx.parent_translation.is_some();

            if has_parent_changes {
                parent_changes.insert(parent_entity, TransformChange {
                    new_position: ctx.parent_new_position,
                    new_rotation: ctx.parent_new_rotation,
                    translation: ctx.parent_translation,
                });
            }
        }

        // Collect child transform changes
        for (child_name, change) in &ctx.child_changes {
            if let Some(&child_entity) = child_name_to_entity.get(child_name) {
                child_changes.insert(child_entity, TransformChange {
                    new_position: change.new_position,
                    new_rotation: change.new_rotation,
                    translation: change.translation,
                });
            }
        }

        // Apply environment changes (to all WorldEnvironmentMarker entities)
        let has_env_changes = ctx.env_sky_mode.is_some()
            || ctx.env_clear_color.is_some()
            || ctx.env_ambient_brightness.is_some()
            || ctx.env_ambient_color.is_some()
            || ctx.env_ev100.is_some()
            || ctx.env_sky_top_color.is_some()
            || ctx.env_sky_horizon_color.is_some()
            || ctx.env_sky_curve.is_some()
            || ctx.env_ground_bottom_color.is_some()
            || ctx.env_ground_horizon_color.is_some()
            || ctx.env_ground_curve.is_some()
            || ctx.env_sun_azimuth.is_some()
            || ctx.env_sun_elevation.is_some()
            || ctx.env_sun_color.is_some()
            || ctx.env_sun_energy.is_some()
            || ctx.env_sun_disk_scale.is_some()
            || ctx.env_fog_enabled.is_some()
            || ctx.env_fog_color.is_some()
            || ctx.env_fog_start.is_some()
            || ctx.env_fog_end.is_some();

        if has_env_changes {
            use crate::shared::SkyMode;
            for mut world_env in world_environments.iter_mut() {
                // General
                if let Some(mode) = ctx.env_sky_mode {
                    world_env.data.sky_mode = match mode {
                        0 => SkyMode::Color,
                        1 => SkyMode::Procedural,
                        2 => SkyMode::Panorama,
                        _ => SkyMode::Procedural,
                    };
                }
                if let Some((r, g, b)) = ctx.env_clear_color {
                    world_env.data.clear_color = (r, g, b);
                }
                if let Some(brightness) = ctx.env_ambient_brightness {
                    world_env.data.ambient_brightness = brightness;
                }
                if let Some((r, g, b)) = ctx.env_ambient_color {
                    world_env.data.ambient_color = (r, g, b);
                }
                if let Some(ev100) = ctx.env_ev100 {
                    world_env.data.ev100 = ev100;
                }

                // Procedural Sky
                if let Some((r, g, b)) = ctx.env_sky_top_color {
                    world_env.data.procedural_sky.sky_top_color = (r, g, b);
                }
                if let Some((r, g, b)) = ctx.env_sky_horizon_color {
                    world_env.data.procedural_sky.sky_horizon_color = (r, g, b);
                }
                if let Some(curve) = ctx.env_sky_curve {
                    world_env.data.procedural_sky.sky_curve = curve;
                }
                if let Some((r, g, b)) = ctx.env_ground_bottom_color {
                    world_env.data.procedural_sky.ground_bottom_color = (r, g, b);
                }
                if let Some((r, g, b)) = ctx.env_ground_horizon_color {
                    world_env.data.procedural_sky.ground_horizon_color = (r, g, b);
                }
                if let Some(curve) = ctx.env_ground_curve {
                    world_env.data.procedural_sky.ground_curve = curve;
                }

                // Sun
                if let Some(azimuth) = ctx.env_sun_azimuth {
                    world_env.data.procedural_sky.sun_angle_azimuth = azimuth;
                }
                if let Some(elevation) = ctx.env_sun_elevation {
                    world_env.data.procedural_sky.sun_angle_elevation = elevation;
                }
                if let Some((r, g, b)) = ctx.env_sun_color {
                    world_env.data.procedural_sky.sun_color = (r, g, b);
                }
                if let Some(energy) = ctx.env_sun_energy {
                    world_env.data.procedural_sky.sun_energy = energy;
                }
                if let Some(scale) = ctx.env_sun_disk_scale {
                    world_env.data.procedural_sky.sun_disk_scale = scale;
                }

                // Fog
                if let Some(enabled) = ctx.env_fog_enabled {
                    world_env.data.fog_enabled = enabled;
                }
                if let Some((r, g, b)) = ctx.env_fog_color {
                    world_env.data.fog_color = (r, g, b);
                }
                if let Some(start) = ctx.env_fog_start {
                    world_env.data.fog_start = start;
                }
                if let Some(end) = ctx.env_fog_end {
                    world_env.data.fog_end = end;
                }
            }
        }

        // Collect Rhai commands for processing after the loop
        for cmd in ctx.commands.drain(..) {
            all_rhai_commands.push((entity, cmd));
        }
    }

    // Apply collected parent changes
    for (parent_entity, change) in parent_changes {
        if let Ok(mut parent_transform) = all_transforms.get_mut(parent_entity) {
            if let Some(pos) = change.new_position {
                parent_transform.translation = pos;
            }
            if let Some(rot) = change.new_rotation {
                parent_transform.rotation = Quat::from_euler(
                    EulerRot::XYZ,
                    rot.x.to_radians(),
                    rot.y.to_radians(),
                    rot.z.to_radians(),
                );
            }
            if let Some(delta) = change.translation {
                parent_transform.translation += delta;
            }
        }
    }

    // Apply collected child changes
    for (child_entity, change) in child_changes {
        if let Ok(mut child_transform) = all_transforms.get_mut(child_entity) {
            if let Some(pos) = change.new_position {
                child_transform.translation = pos;
            }
            if let Some(rot) = change.new_rotation {
                child_transform.rotation = Quat::from_euler(
                    EulerRot::XYZ,
                    rot.x.to_radians(),
                    rot.y.to_radians(),
                    rot.z.to_radians(),
                );
            }
            if let Some(delta) = change.translation {
                child_transform.translation += delta;
            }
        }
    }

    // Process collected Rhai commands
    for (source_entity, cmd) in all_rhai_commands {
        process_rhai_command(&mut commands, &mut visibility_query, source_entity, cmd);
    }
}

/// Process a single Rhai command
fn process_rhai_command(
    commands: &mut Commands,
    visibility_query: &mut Query<&mut Visibility>,
    source_entity: Entity,
    cmd: RhaiCommand,
) {
    match cmd {
        // ECS Commands
        RhaiCommand::SpawnEntity { name } => {
            commands.spawn((
                Transform::default(),
                Visibility::default(),
                EditorEntity {
                    name,
                    tag: String::new(),
                    visible: true,
                    locked: false,
                },
                SceneNode,
            ));
        }
        RhaiCommand::DespawnEntity { entity_id } => {
            let entity = Entity::from_bits(entity_id);
            commands.entity(entity).despawn();
        }
        RhaiCommand::DespawnSelf => {
            commands.entity(source_entity).despawn();
        }
        RhaiCommand::SetEntityName { entity_id, name } => {
            let entity = Entity::from_bits(entity_id);
            commands.entity(entity).insert(EditorEntity {
                name,
                tag: String::new(),
                visible: true,
                locked: false,
            });
        }
        RhaiCommand::AddTag { entity_id, tag } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            // Tags are stored in EditorEntity.tag - would need to query and modify
            info!("[Rhai] AddTag '{}' to entity {:?} (not yet implemented)", tag, entity);
        }
        RhaiCommand::RemoveTag { entity_id, tag } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] RemoveTag '{}' from entity {:?} (not yet implemented)", tag, entity);
        }

        // Audio Commands
        RhaiCommand::PlaySound { path, volume, looping } => {
            info!("[Rhai] PlaySound '{}' volume={} looping={} (audio system not yet integrated)", path, volume, looping);
        }
        RhaiCommand::PlaySound3D { path, volume, position } => {
            info!("[Rhai] PlaySound3D '{}' at {:?} volume={} (audio system not yet integrated)", path, position, volume);
        }
        RhaiCommand::PlayMusic { path, volume, fade_in } => {
            info!("[Rhai] PlayMusic '{}' volume={} fade_in={} (audio system not yet integrated)", path, volume, fade_in);
        }
        RhaiCommand::StopMusic { fade_out } => {
            info!("[Rhai] StopMusic fade_out={} (audio system not yet integrated)", fade_out);
        }
        RhaiCommand::StopAllSounds => {
            info!("[Rhai] StopAllSounds (audio system not yet integrated)");
        }
        RhaiCommand::SetMasterVolume { volume } => {
            info!("[Rhai] SetMasterVolume {} (audio system not yet integrated)", volume);
        }

        // Debug Commands
        RhaiCommand::Log { level, message } => {
            match level.as_str() {
                "error" => error!("[Rhai Script] {}", message),
                "warn" => warn!("[Rhai Script] {}", message),
                "debug" => debug!("[Rhai Script] {}", message),
                "trace" => trace!("[Rhai Script] {}", message),
                _ => info!("[Rhai Script] {}", message),
            }
        }
        RhaiCommand::DrawLine { start, end, color, duration } => {
            // Debug drawing would need gizmos integration
            debug!("[Rhai] DrawLine {:?} -> {:?} color={:?} duration={}", start, end, color, duration);
        }
        RhaiCommand::DrawRay { origin, direction, length, color, duration } => {
            debug!("[Rhai] DrawRay {:?} dir={:?} len={} color={:?} duration={}", origin, direction, length, color, duration);
        }
        RhaiCommand::DrawSphere { center, radius, color, duration } => {
            debug!("[Rhai] DrawSphere {:?} r={} color={:?} duration={}", center, radius, color, duration);
        }
        RhaiCommand::DrawBox { center, half_extents, color, duration } => {
            debug!("[Rhai] DrawBox {:?} half_extents={:?} color={:?} duration={}", center, half_extents, color, duration);
        }
        RhaiCommand::DrawPoint { position, size, color, duration } => {
            debug!("[Rhai] DrawPoint {:?} size={} color={:?} duration={}", position, size, color, duration);
        }

        // Physics Commands
        RhaiCommand::ApplyForce { entity_id, force } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] ApplyForce {:?} to {:?} (physics not yet integrated)", force, entity);
        }
        RhaiCommand::ApplyImpulse { entity_id, impulse } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] ApplyImpulse {:?} to {:?} (physics not yet integrated)", impulse, entity);
        }
        RhaiCommand::ApplyTorque { entity_id, torque } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] ApplyTorque {:?} to {:?} (physics not yet integrated)", torque, entity);
        }
        RhaiCommand::SetVelocity { entity_id, velocity } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] SetVelocity {:?} on {:?} (physics not yet integrated)", velocity, entity);
        }
        RhaiCommand::SetAngularVelocity { entity_id, velocity } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] SetAngularVelocity {:?} on {:?} (physics not yet integrated)", velocity, entity);
        }
        RhaiCommand::SetGravityScale { entity_id, scale } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] SetGravityScale {} on {:?} (physics not yet integrated)", scale, entity);
        }
        RhaiCommand::Raycast { origin, direction, max_distance, result_var } => {
            info!("[Rhai] Raycast from {:?} dir={:?} max={} result_var='{}' (physics not yet integrated)", origin, direction, max_distance, result_var);
        }

        // Timer Commands
        RhaiCommand::StartTimer { name, duration, repeat } => {
            info!("[Rhai] StartTimer '{}' duration={} repeat={} (timer system not yet integrated)", name, duration, repeat);
        }
        RhaiCommand::StopTimer { name } => {
            info!("[Rhai] StopTimer '{}' (timer system not yet integrated)", name);
        }
        RhaiCommand::PauseTimer { name } => {
            info!("[Rhai] PauseTimer '{}' (timer system not yet integrated)", name);
        }
        RhaiCommand::ResumeTimer { name } => {
            info!("[Rhai] ResumeTimer '{}' (timer system not yet integrated)", name);
        }

        // Scene Commands
        RhaiCommand::LoadScene { path } => {
            info!("[Rhai] LoadScene '{}' (scene loading not yet integrated)", path);
        }
        RhaiCommand::UnloadScene { handle_id } => {
            info!("[Rhai] UnloadScene {} (scene loading not yet integrated)", handle_id);
        }
        RhaiCommand::SpawnPrefab { path, position, rotation } => {
            info!("[Rhai] SpawnPrefab '{}' at {:?} rotation={:?} (prefab system not yet integrated)", path, position, rotation);
        }

        // Animation Commands
        RhaiCommand::PlayAnimation { entity_id, name, looping, speed } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] PlayAnimation '{}' on {:?} looping={} speed={} (animation not yet integrated)", name, entity, looping, speed);
        }
        RhaiCommand::StopAnimation { entity_id } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] StopAnimation on {:?} (animation not yet integrated)", entity);
        }
        RhaiCommand::SetAnimationSpeed { entity_id, speed } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] SetAnimationSpeed {} on {:?} (animation not yet integrated)", speed, entity);
        }

        // Rendering Commands
        RhaiCommand::SetVisibility { entity_id, visible } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            if let Ok(mut vis) = visibility_query.get_mut(entity) {
                *vis = if visible { Visibility::Inherited } else { Visibility::Hidden };
            }
        }
        RhaiCommand::SetMaterialColor { entity_id, color: _ } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] SetMaterialColor on {:?} (material system not yet integrated)", entity);
        }
        RhaiCommand::SetLightIntensity { entity_id, intensity } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] SetLightIntensity {} on {:?} (light system not yet integrated)", intensity, entity);
        }
        RhaiCommand::SetLightColor { entity_id, color: _ } => {
            let entity = entity_id
                .map(|id| Entity::from_bits(id))
                .unwrap_or(source_entity);
            info!("[Rhai] SetLightColor on {:?} (light system not yet integrated)", entity);
        }

        // Camera Commands
        RhaiCommand::SetCameraTarget { position } => {
            info!("[Rhai] SetCameraTarget {:?} (camera system not yet integrated)", position);
        }
        RhaiCommand::SetCameraZoom { zoom } => {
            info!("[Rhai] SetCameraZoom {} (camera system not yet integrated)", zoom);
        }
        RhaiCommand::ScreenShake { intensity, duration } => {
            info!("[Rhai] ScreenShake intensity={} duration={} (camera system not yet integrated)", intensity, duration);
        }
    }
}
