script MeshGeometryDemo {
  props Mesh_Creation {
    mesh_type: select {
      default: "box",
      options: ["box", "sphere", "cylinder", "plane", "ground", "torus", "cone", "polyhedron"],
      description: "Type of mesh to create",
      once: true
    }
    
    mesh_size: range {
      default: 1.0,
      min: 0.1,
      max: 10.0,
      description: "Size of the generated mesh"
    }
    
    mesh_segments: range {
      default: 16.0,
      min: 3.0,
      max: 64.0,
      description: "Number of segments for curved meshes"
    }
    
    create_instances: boolean {
      default: false,
      description: "Create instances instead of clones",
      once: true
    }
    
    instance_count: range {
      default: 10.0,
      min: 1.0,
      max: 100.0,
      description: "Number of instances to create"
    }
  }
  
  props Geometry_Operations {
    enable_morphing: boolean {
      default: false,
      description: "Enable mesh morphing animation",
      once: true
    }
    
    enable_subdivision: boolean {
      default: false,
      description: "Enable mesh subdivision",
      once: true
    }
    
    subdivision_levels: range {
      default: 1.0,
      min: 1.0,
      max: 4.0,
      description: "Number of subdivision levels"
    }
    
    enable_simplification: boolean {
      default: false,
      description: "Enable mesh simplification",
      once: true
    }
    
    simplification_factor: range {
      default: 0.5,
      min: 0.1,
      max: 0.9,
      description: "Simplification factor (lower = more simplified)"
    }
  }
  
  props Advanced_Features {
    enable_vertex_colors: boolean {
      default: false,
      description: "Enable per-vertex coloring",
      once: true
    }
    
    enable_decals: boolean {
      default: false,
      description: "Enable mesh decals",
      once: true
    }
    
    enable_billboard: boolean {
      default: false,
      description: "Enable billboard mode",
      once: true
    }
    
    billboard_mode: select {
      default: "all",
      options: ["all", "y", "none"],
      description: "Billboard constraint mode"
    }
    
    enable_line_mesh: boolean {
      default: false,
      description: "Create line mesh instead of solid",
      once: true
    }
    
    line_width: range {
      default: 1.0,
      min: 0.1,
      max: 10.0,
      description: "Line width for line meshes"
    }
  }
  
  props Procedural_Generation {
    enable_height_map: boolean {
      default: false,
      description: "Generate mesh from height map",
      once: true
    }
    
    height_map_resolution: range {
      default: 64.0,
      min: 16.0,
      max: 256.0,
      description: "Height map resolution"
    }
    
    height_amplitude: range {
      default: 5.0,
      min: 0.1,
      max: 20.0,
      description: "Height variation amplitude"
    }
    
    noise_scale: range {
      default: 0.1,
      min: 0.01,
      max: 1.0,
      description: "Noise scale for procedural generation"
    }
  }
  
  # Mesh state variables
  generated_meshes = []
  instance_meshes = []
  morph_targets = []
  vertex_data = null
  original_vertices = []
  procedural_mesh = null
  
  # Animation state
  morph_time = 0.0
  vertex_animation_time = 0.0
  
  start {
    log("Mesh Geometry Demo initialized")
    add_tag("geometry_demo")
    
    # Generate the primary mesh
    generate_primary_mesh()
    
    # Set up advanced features
    setup_advanced_features()
    
    # Create instances if enabled
    if (create_instances) {
      create_mesh_instances()
    }
    
    # Set up procedural generation
    if (enable_height_map) {
      generate_procedural_mesh()
    }
  }
  
  update(dt) {
    morph_time = morph_time + dt
    vertex_animation_time = vertex_animation_time + dt
    
    # Handle morphing animation
    if (enable_morphing && morph_targets_count > 0) {
      update_morph_animation()
    }
    
    # Handle vertex animation
    if (enable_vertex_colors) {
      animate_vertex_colors()
    }
    
    # Update procedural mesh
    if (procedural_mesh) {
      update_procedural_mesh()
    }
    
    # Handle input for mesh operations
    handle_mesh_input()
    
    # Update instances
    update_instances()
  }
  
  # === MESH GENERATION ===
  
  generate_primary_mesh() {
    log("Generating primary mesh: " + mesh_type)
    
    switch (mesh_type) {
      case "box":
        create_box_mesh()
        break
      case "sphere":
        create_sphere_mesh()
        break
      case "cylinder":
        create_cylinder_mesh()
        break
      case "plane":
        create_plane_mesh()
        break
      case "ground":
        create_ground_mesh()
        break
      case "torus":
        create_torus_mesh()
        break
      case "cone":
        create_cone_mesh()
        break
      case "polyhedron":
        create_polyhedron_mesh()
        break
    }
    
    # Apply geometry operations
    if (enable_subdivision) {
      subdivide_mesh()
    }
    
    if (enable_simplification) {
      simplify_mesh()
    }
  }
  
  create_box_mesh() {
    # This would create a box mesh using Babylon.js MeshBuilder
    log("Created box mesh with size: " + mesh_size)
    add_tag("box_mesh")
  }
  
  create_sphere_mesh() {
    log("Created sphere mesh - Size: " + mesh_size + ", Segments: " + mesh_segments)
    add_tag("sphere_mesh")
  }
  
  create_cylinder_mesh() {
    log("Created cylinder mesh - Size: " + mesh_size + ", Segments: " + mesh_segments)
    add_tag("cylinder_mesh")
  }
  
  create_plane_mesh() {
    log("Created plane mesh with size: " + mesh_size)
    add_tag("plane_mesh")
  }
  
  create_ground_mesh() {
    log("Created ground mesh - Size: " + mesh_size + ", Subdivisions: " + mesh_segments)
    add_tag("ground_mesh")
  }
  
  create_torus_mesh() {
    log("Created torus mesh - Size: " + mesh_size + ", Segments: " + mesh_segments)
    add_tag("torus_mesh")
  }
  
  create_cone_mesh() {
    log("Created cone mesh - Size: " + mesh_size + ", Segments: " + mesh_segments)
    add_tag("cone_mesh")
  }
  
  create_polyhedron_mesh() {
    log("Created polyhedron mesh with size: " + mesh_size)
    add_tag("polyhedron_mesh")
  }
  
  # === GEOMETRY OPERATIONS ===
  
  subdivide_mesh() {
    log("Subdividing mesh - Levels: " + subdivision_levels)
    
    # This would use Babylon.js mesh subdivision
    for (i = 0; i < subdivision_levels; i++) {
      # mesh.subdivide(...)
      log("Applied subdivision level: " + (i + 1))
    }
    
    add_tag("subdivided")
  }
  
  simplify_mesh() {
    log("Simplifying mesh - Factor: " + simplification_factor)
    
    # This would use Babylon.js mesh simplification
    # mesh.simplify([{ quality: simplification_factor, distance: 100 }])
    
    add_tag("simplified")
  }
  
  optimize_mesh() {
    log("Optimizing mesh geometry")
    
    # This would merge vertices, optimize indices, etc.
    # mesh.optimize()
    
    add_tag("optimized")
  }
  
  # === INSTANCING ===
  
  create_mesh_instances() {
    log("Creating " + instance_count + " mesh instances")
    
    for (i = 0; i < instance_count; i++) {
      # Calculate instance position
      angle = (i / instance_count) * 2 * PI
      radius = 5.0
      offset_x = cos(angle) * radius
      offset_z = sin(angle) * radius
      offset_y = sin(i * 0.5) * 2.0
      
      # Create instance (this would use Babylon.js instancing)
      instance = {
        id: i,
        position: [offset_x, offset_y, offset_z],
        rotation: [0, angle, 0],
        scale: [1, 1, 1]
      }
      
      instance_meshes.push(instance)
      
      log("Created instance " + i + " at position: " + offset_x + ", " + offset_y + ", " + offset_z)
    }
    
    add_tag("instanced")
  }
  
  update_instances() {
    if (instance_meshes.length == 0) {
      return
    }
    
    # Animate instances
    for (i = 0; i < instance_meshes.length; i++) {
      instance = instance_meshes[i]
      
      # Floating animation
      float_offset = sin(vertex_animation_time + i * 0.5) * 0.5
      instance.position[1] = instance.position[1] + float_offset * 0.01
      
      # Rotation animation
      instance.rotation[1] = instance.rotation[1] + 0.01
      
      # Scale pulsing
      scale_factor = 1.0 + sin(vertex_animation_time * 2 + i) * 0.1
      instance.scale = [scale_factor, scale_factor, scale_factor]
    }
  }
  
  # === MORPHING & VERTEX ANIMATION ===
  
  setup_morph_targets() {
    if (!enable_morphing) {
      return
    }
    
    log("Setting up morph targets")
    
    # Create morph targets (simplified representation)
    morph_targets = [
      { name: "inflated", factor: 0.0 },
      { name: "twisted", factor: 0.0 },
      { name: "stretched", factor: 0.0 }
    ]
    
    add_tag("morphing")
  }
  
  update_morph_animation() {
    # Animate morph targets
    morph_targets[0].factor = (sin(morph_time * 0.5) + 1.0) * 0.5  # Inflate
    morph_targets[1].factor = (sin(morph_time * 0.3 + 1) + 1.0) * 0.5  # Twist
    morph_targets[2].factor = (sin(morph_time * 0.7 + 2) + 1.0) * 0.5  # Stretch
    
    # Apply morph targets to mesh
    # This would update the mesh vertex positions based on morph targets
  }
  
  animate_vertex_colors() {
    # Animate per-vertex colors
    if (!vertex_data) {
      return
    }
    
    # This would modify vertex color data
    # Create rainbow effect or other color animations
    
    color_cycle = sin(vertex_animation_time) * 0.5 + 0.5
    set_color(color_cycle, 1.0 - color_cycle, 0.5)
  }
  
  # === ADVANCED FEATURES ===
  
  setup_advanced_features() {
    if (enable_vertex_colors) {
      setup_vertex_colors()
    }
    
    if (enable_billboard) {
      setup_billboard_mode()
    }
    
    if (enable_line_mesh) {
      convert_to_line_mesh()
    }
    
    if (enable_morphing) {
      setup_morph_targets()
    }
  }
  
  setup_vertex_colors() {
    log("Setting up vertex colors")
    
    # This would assign colors to each vertex
    # Generate rainbow colors or other patterns
    
    add_tag("vertex_colored")
  }
  
  setup_billboard_mode() {
    log("Setting up billboard mode: " + billboard_mode)
    
    # This would set the mesh to always face the camera
    # set_billboard_mode(billboard_mode)
    
    add_tag("billboard")
  }
  
  convert_to_line_mesh() {
    log("Converting to line mesh - Width: " + line_width)
    
    # This would convert the solid mesh to lines/wireframe
    set_wireframe(true)
    
    add_tag("line_mesh")
  }
  
  # === PROCEDURAL GENERATION ===
  
  generate_procedural_mesh() {
    log("Generating procedural mesh from height map")
    log("Resolution: " + height_map_resolution + ", Amplitude: " + height_amplitude)
    
    # Generate height map using noise
    height_map = generate_height_map()
    
    # Create mesh from height map
    procedural_mesh = create_mesh_from_height_map(height_map)
    
    add_tag("procedural")
  }
  
  generate_height_map() {
    log("Generating height map with noise scale: " + noise_scale)
    
    height_map = []
    resolution = height_map_resolution
    
    for (y = 0; y < resolution; y++) {
      row = []
      for (x = 0; x < resolution; x++) {
        # Generate height using simple noise function
        height = generate_noise(x * noise_scale, y * noise_scale) * height_amplitude
        row.push(height)
      }
      height_map.push(row)
    }
    
    return height_map
  }
  
  generate_noise(x, y) {
    # Simple noise function (placeholder)
    return sin(x * 2.7) * sin(y * 3.1) * 0.5 + 
           sin(x * 5.4) * sin(y * 6.2) * 0.25 +
           sin(x * 10.8) * sin(y * 12.4) * 0.125
  }
  
  create_mesh_from_height_map(height_map) {
    log("Creating mesh from height map data")
    
    # This would create vertices and indices from the height map
    vertices = []
    indices = []
    
    resolution = height_map.length
    
    # Generate vertices
    for (y = 0; y < resolution; y++) {
      for (x = 0; x < resolution; x++) {
        height = height_map[y][x]
        
        # Vertex position
        vertex_x = (x / (resolution - 1)) * mesh_size - mesh_size * 0.5
        vertex_z = (y / (resolution - 1)) * mesh_size - mesh_size * 0.5
        vertex_y = height
        
        vertices.push([vertex_x, vertex_y, vertex_z])
      }
    }
    
    # Generate indices (triangles)
    for (y = 0; y < resolution - 1; y++) {
      for (x = 0; x < resolution - 1; x++) {
        # Current quad indices
        i0 = y * resolution + x
        i1 = y * resolution + (x + 1)
        i2 = (y + 1) * resolution + x
        i3 = (y + 1) * resolution + (x + 1)
        
        # Two triangles per quad
        indices.push([i0, i2, i1])
        indices.push([i1, i2, i3])
      }
    }
    
    log("Generated mesh: " + vertices.length + " vertices, " + (indices.length * 3) + " triangles")
    
    return {
      vertices: vertices,
      indices: indices
    }
  }
  
  update_procedural_mesh() {
    # Update the procedural mesh (e.g., for animated terrain)
    if (!procedural_mesh) {
      return
    }
    
    # Animate the height map
    time_offset = vertex_animation_time * 0.1
    
    # This would update vertex positions based on time
    # for dynamic/animated procedural geometry
  }
  
  # === MESH OPERATIONS ===
  
  perform_boolean_operation(operation, other_mesh) {
    log("Performing boolean operation: " + operation)
    
    # This would use Constructive Solid Geometry (CSG)
    switch (operation) {
      case "union":
        log("Union with mesh: " + other_mesh.name)
        break
      case "subtract":
        log("Subtract mesh: " + other_mesh.name)
        break
      case "intersect":
        log("Intersect with mesh: " + other_mesh.name)
        break
    }
    
    add_tag("boolean_" + operation)
  }
  
  merge_nearby_meshes() {
    position = get_position()
    nearby = get_objects_in_radius(position[0], position[1], position[2], 3.0)
    
    meshes_to_merge = []
    for (i = 0; i < nearby.length; i++) {
      obj = nearby[i].object
      if (obj != this.babylonObject && obj.geometry) {
        meshes_to_merge.push(obj)
      }
    }
    
    if (meshes_to_merge.length > 0) {
      log("Merging " + meshes_to_merge.length + " nearby meshes")
      
      # This would merge the meshes
      # merged_mesh = merge_meshes(meshes_to_merge)
      
      add_tag("merged")
    }
  }
  
  # === DECALS ===
  
  create_decals() {
    if (!enable_decals) {
      return
    }
    
    log("Creating mesh decals")
    
    # This would create decal projections on the mesh surface
    decal_positions = [
      [0.5, 0.5, 0.5],
      [-0.5, 0.5, 0.5],
      [0, -0.5, 0.5]
    ]
    
    for (i = 0; i < decal_positions.length; i++) {
      pos = decal_positions[i]
      # create_decal(pos, normal, size, texture)
      log("Created decal at: " + pos[0] + ", " + pos[1] + ", " + pos[2])
    }
    
    add_tag("has_decals")
  }
  
  # === VERTEX DATA OPERATIONS ===
  
  extract_vertex_data() {
    log("Extracting vertex data from mesh")
    
    # This would extract positions, normals, UVs, colors, etc.
    vertex_data = {
      positions: [],  # [x,y,z,x,y,z,...]
      normals: [],    # [nx,ny,nz,nx,ny,nz,...]
      uvs: [],        # [u,v,u,v,...]
      colors: [],     # [r,g,b,a,r,g,b,a,...]
      indices: []     # [0,1,2,0,2,3,...]
    }
    
    log("Extracted vertex data - Positions: " + (vertex_data.positions.length / 3))
    
    return vertex_data
  }
  
  compute_normals() {
    log("Computing mesh normals")
    
    # This would recalculate vertex normals
    # compute_normals()
    
    add_tag("normals_computed")
  }
  
  flip_normals() {
    log("Flipping mesh normals")
    
    # This would invert all normal vectors
    # flip_normals()
    
    add_tag("normals_flipped")
  }
  
  # === INPUT HANDLING ===
  
  handle_mesh_input() {
    # Geometry operations
    if (is_key_pressed("g")) {
      generate_primary_mesh()
    }
    
    if (is_key_pressed("s")) {
      subdivide_mesh()
    }
    
    if (is_key_pressed("p")) {
      simplify_mesh()
    }
    
    if (is_key_pressed("o")) {
      optimize_mesh()
    }
    
    if (is_key_pressed("n")) {
      compute_normals()
    }
    
    if (is_key_pressed("f")) {
      flip_normals()
    }
    
    # Boolean operations (need another mesh)
    if (is_key_pressed("u")) {
      nearby = get_objects_in_radius(position[0], position[1], position[2], 2.0)
      if (nearby.length > 1) {
        other_mesh = nearby[1].object  # First other mesh
        perform_boolean_operation("union", other_mesh)
      }
    }
    
    # Merge nearby meshes
    if (is_key_pressed("m")) {
      merge_nearby_meshes()
    }
    
    # Create decals
    if (is_key_pressed("d")) {
      create_decals()
    }
    
    # Toggle wireframe
    if (is_key_pressed("w")) {
      set_wireframe(!get_material_property("wireframe"))
    }
    
    # Extract vertex data
    if (is_key_pressed("x")) {
      vertex_data = extract_vertex_data()
    }
    
    # Regenerate procedural mesh
    if (is_key_pressed("r") && enable_height_map) {
      generate_procedural_mesh()
    }
  }
  
  # === MESH ANALYSIS ===
  
  analyze_mesh() {
    bounding = get_bounding_info()
    if (bounding) {
      log("=== MESH ANALYSIS ===")
      log("Bounding Box Min: " + bounding.min[0] + ", " + bounding.min[1] + ", " + bounding.min[2])
      log("Bounding Box Max: " + bounding.max[0] + ", " + bounding.max[1] + ", " + bounding.max[2])
      log("Bounding Box Size: " + bounding.size[0] + ", " + bounding.size[1] + ", " + bounding.size[2])
      log("Bounding Box Center: " + bounding.center[0] + ", " + bounding.center[1] + ", " + bounding.center[2])
      
      # Calculate surface area and volume approximations
      size = bounding.size
      surface_area = 2 * (size[0] * size[1] + size[1] * size[2] + size[0] * size[2])
      volume = size[0] * size[1] * size[2]
      
      log("Approximate Surface Area: " + surface_area.toFixed(2))
      log("Approximate Volume: " + volume.toFixed(2))
    }
    
    if (vertex_data) {
      vertex_count = vertex_data.positions.length / 3
      triangle_count = vertex_data.indices.length / 3
      
      log("Vertex Count: " + vertex_count)
      log("Triangle Count: " + triangle_count)
      log("Index Count: " + vertex_data.indices.length)
    }
  }
  
  destroy {
    log("Mesh Geometry Demo destroyed")
    
    # Clean up generated meshes
    for (i = 0; i < generated_meshes.length; i++) {
      dispose_object(generated_meshes[i])
    }
    generated_meshes = []
    
    # Clean up instances
    for (i = 0; i < instance_meshes.length; i++) {
      # dispose instance
    }
    instance_meshes = []
    
    # Clean up procedural mesh
    if (procedural_mesh) {
      procedural_mesh = null
    }
    
    # Clear vertex data
    vertex_data = null
    original_vertices = []
    morph_targets = []
  }
}