script CompleteInputDemo {
  props Input_Settings {
    mouse_sensitivity: range {
      default: 2.0,
      min: 0.1,
      max: 10.0,
      description: "Mouse sensitivity for camera control"
    }
    
    gamepad_deadzone: range {
      default: 0.2,
      min: 0.0,
      max: 0.5,
      description: "Gamepad analog stick deadzone"
    }
    
    movement_speed: range {
      default: 5.0,
      min: 0.1,
      max: 20.0,
      description: "Movement speed multiplier"
    }
    
    enable_keyboard: boolean {
      default: true,
      description: "Enable keyboard input"
    }
    
    enable_mouse: boolean {
      default: true,
      description: "Enable mouse input"
    }
    
    enable_gamepad: boolean {
      default: true,
      description: "Enable gamepad input"
    }
    
    enable_touch: boolean {
      default: true,
      description: "Enable touch input"
    }
  }
  
  props Key_Bindings {
    move_forward: string {
      default: "w",
      description: "Move forward key"
    }
    
    move_backward: string {
      default: "s",
      description: "Move backward key"
    }
    
    move_left: string {
      default: "a",
      description: "Move left key"
    }
    
    move_right: string {
      default: "d",
      description: "Move right key"
    }
    
    jump: string {
      default: "space",
      description: "Jump key"
    }
    
    action: string {
      default: "enter",
      description: "Action key"
    }
    
    menu: string {
      default: "escape",
      description: "Menu key"
    }
  }
  
  # Input state variables
  movement_vector = [0, 0, 0]
  rotation_input = [0, 0]
  last_mouse_position = [0, 0]
  pointer_locked = false
  touch_start_positions = {}
  input_history = []
  active_combo = []
  combo_timer = 0
  
  start {
    log("Complete Input Demo initialized")
    add_tag("input_demo")
    
    # Set up input event handlers
    setup_input_events()
    
    # Initialize input state
    reset_input_state()
  }
  
  update(dt) {
    # Clear movement vector each frame
    movement_vector = [0, 0, 0]
    rotation_input = [0, 0]
    
    # Process all input types
    if (enable_keyboard) process_keyboard_input(dt)
    if (enable_mouse) process_mouse_input(dt)
    if (enable_gamepad) process_gamepad_input(dt)
    if (enable_touch) process_touch_input(dt)
    
    # Apply accumulated input
    apply_movement(dt)
    apply_rotation(dt)
    
    # Update input history for combos
    update_input_combos(dt)
    
    # Debug input display
    display_input_debug()
  }
  
  # === KEYBOARD INPUT ===
  
  process_keyboard_input(dt) {
    # Movement keys
    if (is_key_pressed(move_forward)) {
      movement_vector[2] = movement_vector[2] + 1.0
    }
    if (is_key_pressed(move_backward)) {
      movement_vector[2] = movement_vector[2] - 1.0
    }
    if (is_key_pressed(move_left)) {
      movement_vector[0] = movement_vector[0] - 1.0
    }
    if (is_key_pressed(move_right)) {
      movement_vector[0] = movement_vector[0] + 1.0
    }
    
    # Jump
    if (is_key_pressed(jump)) {
      movement_vector[1] = movement_vector[1] + 1.0
    }
    
    # Modifier keys
    if (is_ctrl_pressed()) {
      movement_vector[0] = movement_vector[0] * 0.5  # Slow movement
      movement_vector[2] = movement_vector[2] * 0.5
    }
    
    if (is_shift_pressed()) {
      movement_vector[0] = movement_vector[0] * 2.0  # Fast movement
      movement_vector[2] = movement_vector[2] * 2.0
    }
    
    # Key combinations
    if (is_key_combo_pressed(["ctrl", "alt", "d"])) {
      log("Debug combo activated!")
      set_color(1.0, 0.0, 1.0)  # Magenta debug color
    }
    
    # Arrow keys for fine rotation
    if (is_key_pressed("left")) {
      rotation_input[1] = rotation_input[1] - 1.0
    }
    if (is_key_pressed("right")) {
      rotation_input[1] = rotation_input[1] + 1.0
    }
    if (is_key_pressed("up")) {
      rotation_input[0] = rotation_input[0] - 1.0
    }
    if (is_key_pressed("down")) {
      rotation_input[0] = rotation_input[0] + 1.0
    }
    
    # Special actions
    if (is_key_pressed(action)) {
      perform_action()
    }
    
    if (is_key_pressed(menu)) {
      toggle_menu()
    }
    
    # Function keys
    if (is_key_pressed("F1")) {
      toggle_input_debug()
    }
    
    if (is_key_pressed("F2")) {
      reset_object_transform()
    }
    
    # Number keys for quick actions
    for (i = 1; i <= 9; i++) {
      key = "Digit" + i
      if (is_key_pressed(key)) {
        perform_numbered_action(i)
      }
    }
    
    # Record input for combos
    pressed_keys = get_pressed_keys()
    if (pressed_keys.length > 0) {
      record_input("key", pressed_keys[0])
    }
  }
  
  # === MOUSE INPUT ===
  
  process_mouse_input(dt) {
    mouse_pos = get_mouse_position()
    mouse_x = get_mouse_x()
    mouse_y = get_mouse_y()
    normalized_mouse = get_mouse_normalized()
    
    # Mouse movement for camera control
    if (pointer_locked || is_right_mouse_button_pressed()) {
      mouse_delta_x = mouse_x - last_mouse_position[0]
      mouse_delta_y = mouse_y - last_mouse_position[1]
      
      rotation_input[1] = rotation_input[1] + mouse_delta_x * mouse_sensitivity * dt
      rotation_input[0] = rotation_input[0] + mouse_delta_y * mouse_sensitivity * dt
    }
    
    last_mouse_position = [mouse_x, mouse_y]
    
    # Mouse buttons
    if (is_left_mouse_button_pressed()) {
      # Pick objects at mouse position
      picked_object = pick_object(mouse_x, mouse_y)
      if (picked_object) {
        log("Left clicked on: " + picked_object.name)
        interact_with_object(picked_object)
      }
      
      record_input("mouse", "left_click")
    }
    
    if (is_right_mouse_button_pressed()) {
      # Context menu or special action
      log("Right mouse button held")
      set_emissive_color(0.1, 0.1, 0.0)
      
      record_input("mouse", "right_click")
    } else {
      set_emissive_color(0.0, 0.0, 0.0)
    }
    
    if (is_middle_mouse_button_pressed()) {
      # Reset view or special function
      reset_camera_view()
      record_input("mouse", "middle_click")
    }
    
    # Mouse wheel simulation (if available)
    # This would need additional mouse wheel event handling
    
    # Pointer lock toggle
    if (is_key_pressed("l") && is_ctrl_pressed()) {
      if (pointer_locked) {
        exit_pointer_lock()
        pointer_locked = false
      } else {
        request_pointer_lock()
        pointer_locked = true
      }
    }
  }
  
  # === GAMEPAD INPUT ===
  
  process_gamepad_input(dt) {
    if (!is_gamepad_connected()) return
    
    gamepad = get_gamepad(0)
    if (!gamepad) return
    
    # Left stick for movement
    left_stick = get_left_stick_with_deadzone(gamepad_deadzone)
    movement_vector[0] = movement_vector[0] + left_stick[0]
    movement_vector[2] = movement_vector[2] - left_stick[1]  # Invert Y for forward/back
    
    # Right stick for camera rotation
    right_stick = get_right_stick_with_deadzone(gamepad_deadzone)
    rotation_input[1] = rotation_input[1] + right_stick[0] * 2.0
    rotation_input[0] = rotation_input[0] + right_stick[1] * 2.0
    
    # Face buttons
    if (is_gamepad_button_a()) {
      movement_vector[1] = movement_vector[1] + 1.0  # Jump
      record_input("gamepad", "A")
    }
    
    if (is_gamepad_button_b()) {
      perform_action()
      record_input("gamepad", "B")
    }
    
    if (is_gamepad_button_x()) {
      log("Gamepad X pressed")
      set_color(0.0, 1.0, 1.0)  # Cyan
      record_input("gamepad", "X")
    }
    
    if (is_gamepad_button_y()) {
      toggle_menu()
      record_input("gamepad", "Y")
    }
    
    # Shoulder buttons
    if (is_gamepad_button_pressed(4)) {  # Left shoulder
      movement_vector[0] = movement_vector[0] * 0.5  # Slow strafe
    }
    
    if (is_gamepad_button_pressed(5)) {  # Right shoulder
      movement_vector[0] = movement_vector[0] * 2.0  # Fast strafe
    }
    
    # Triggers
    left_trigger = get_left_trigger()
    right_trigger = get_right_trigger()
    
    if (left_trigger > 0.1) {
      # Slow movement
      movement_vector[0] = movement_vector[0] * (1.0 - left_trigger * 0.5)
      movement_vector[2] = movement_vector[2] * (1.0 - left_trigger * 0.5)
    }
    
    if (right_trigger > 0.1) {
      # Boost movement
      boost_factor = 1.0 + right_trigger * 2.0
      movement_vector[0] = movement_vector[0] * boost_factor
      movement_vector[2] = movement_vector[2] * boost_factor
    }
    
    # D-pad for discrete actions
    if (is_gamepad_button_pressed(12)) {  # D-pad up
      perform_numbered_action(1)
    }
    if (is_gamepad_button_pressed(13)) {  # D-pad down
      perform_numbered_action(2)
    }
    if (is_gamepad_button_pressed(14)) {  # D-pad left
      perform_numbered_action(3)
    }
    if (is_gamepad_button_pressed(15)) {  # D-pad right
      perform_numbered_action(4)
    }
    
    # Vibration feedback on actions
    if (is_gamepad_button_a() || is_gamepad_button_b()) {
      vibrate_gamepad(0, 0.5, 100)
    }
  }
  
  # === TOUCH INPUT ===
  
  process_touch_input(dt) {
    if (!is_touching()) return
    
    touches = get_touches()
    touch_count = get_touch_count()
    
    if (touch_count == 1) {
      # Single touch - movement
      touch = get_touch(0)
      if (touch) {
        # Convert touch position to movement
        normalized_x = (touch.x / screen_width) * 2 - 1
        normalized_y = (touch.y / screen_height) * 2 - 1
        
        movement_vector[0] = movement_vector[0] + normalized_x * 0.5
        movement_vector[2] = movement_vector[2] - normalized_y * 0.5
        
        record_input("touch", "single")
      }
    } else if (touch_count == 2) {
      # Two finger gestures
      touch1 = get_touch(0)
      touch2 = get_touch(1)
      
      if (touch1 && touch2) {
        # Pinch to zoom/scale
        pinch_distance = get_pinch_distance()
        
        # Store initial pinch distance
        if (!touch_start_positions.pinch_distance) {
          touch_start_positions.pinch_distance = pinch_distance
        }
        
        pinch_ratio = pinch_distance / touch_start_positions.pinch_distance
        scale_factor = clamp(pinch_ratio, 0.5, 2.0)
        set_scale(scale_factor, scale_factor, scale_factor)
        
        # Two finger rotation
        touch_center = get_touch_center()
        angle = atan2(touch2.y - touch1.y, touch2.x - touch1.x)
        
        if (!touch_start_positions.rotation_angle) {
          touch_start_positions.rotation_angle = angle
        }
        
        rotation_delta = angle - touch_start_positions.rotation_angle
        rotation_input[1] = rotation_input[1] + rotation_delta * 0.1
        
        record_input("touch", "two_finger")
      }
    } else if (touch_count >= 3) {
      # Three+ finger gestures
      touch_center = get_touch_center()
      
      # Three finger tap to reset
      if (touch_count == 3) {
        reset_object_transform()
        record_input("touch", "three_finger")
      }
    }
    
    # Update touch state
    if (touch_count == 0) {
      touch_start_positions = {}
    }
  }
  
  # === INPUT APPLICATION ===
  
  apply_movement(dt) {
    if (movement_vector[0] == 0 && movement_vector[1] == 0 && movement_vector[2] == 0) return
    
    # Normalize movement vector
    magnitude = sqrt(
      movement_vector[0] * movement_vector[0] + 
      movement_vector[1] * movement_vector[1] + 
      movement_vector[2] * movement_vector[2]
    )
    
    if (magnitude > 0) {
      normalized = normalize(movement_vector[0], movement_vector[1], movement_vector[2])
      
      # Apply movement
      move_amount_x = normalized[0] * movement_speed * dt
      move_amount_y = normalized[1] * movement_speed * dt
      move_amount_z = normalized[2] * movement_speed * dt
      
      move_by(move_amount_x, move_amount_y, move_amount_z)
    }
  }
  
  apply_rotation(dt) {
    if (rotation_input[0] == 0 && rotation_input[1] == 0) return
    
    # Apply rotation
    rotate_by(
      rotation_input[0] * dt,
      rotation_input[1] * dt,
      0
    )
  }
  
  # === INPUT EVENTS ===
  
  setup_input_events() {
    # Set up key event handlers
    on_key_down((event) => {
      log("Key pressed: " + event.code)
      handle_key_event("down", event.code)
    })
    
    on_key_up((event) => {
      log("Key released: " + event.code)
      handle_key_event("up", event.code)
    })
    
    on_mouse_down((event) => {
      log("Mouse button pressed: " + event.button)
      handle_mouse_event("down", event.button)
    })
    
    on_mouse_up((event) => {
      log("Mouse button released: " + event.button)
      handle_mouse_event("up", event.button)
    })
  }
  
  handle_key_event(type, key) {
    # Custom key event handling
    if (type == "down") {
      if (key == "KeyR") {
        reset_object_transform()
      } else if (key == "KeyC") {
        set_color(random(), random(), random())
      } else if (key == "KeyT") {
        # Take input snapshot
        snapshot = get_input_snapshot()
        log("Input snapshot taken: " + snapshot.timestamp)
      }
    }
  }
  
  handle_mouse_event(type, button) {
    # Custom mouse event handling
    if (type == "down" && button == 0) {
      # Left mouse down
      set_emissive_color(0.0, 0.2, 0.0)
    } else if (type == "up" && button == 0) {
      # Left mouse up
      set_emissive_color(0.0, 0.0, 0.0)
    }
  }
  
  # === INPUT COMBOS ===
  
  record_input(type, input) {
    current_time = get_time()
    input_history.push({
      type: type,
      input: input,
      time: current_time
    })
    
    # Keep only recent history
    if (input_history.length > 10) {
      input_history.shift()
    }
    
    # Check for combos
    check_input_combos()
  }
  
  update_input_combos(dt) {
    if (combo_timer > 0) {
      combo_timer = combo_timer - dt
      if (combo_timer <= 0) {
        active_combo = []
      }
    }
  }
  
  check_input_combos() {
    # Simple combo detection
    if (input_history.length >= 3) {
      recent = input_history.slice(-3)
      
      # Check for specific combos
      if (recent[0].input == "w" && recent[1].input == "w" && recent[2].input == "space") {
        execute_combo("double_forward_jump")
      } else if (recent[0].input == "A" && recent[1].input == "B" && recent[2].input == "A") {
        execute_combo("gamepad_aba")
      }
    }
  }
  
  execute_combo(combo_name) {
    log("Combo executed: " + combo_name)
    
    switch (combo_name) {
      case "double_forward_jump":
        # Super jump
        move_by(0, 5.0, 2.0)
        set_color(1.0, 1.0, 0.0)  # Yellow
        break
      
      case "gamepad_aba":
        # Special effect
        animate_color(1.0, 0.0, 1.0, 500, "bounce")
        break
    }
    
    # Vibrate gamepad on combo
    vibrate_gamepad(0, 1.0, 300)
  }
  
  # === ACTIONS ===
  
  perform_action() {
    log("Action performed!")
    set_color(0.0, 1.0, 0.0)  # Green
    
    # Find nearby objects to interact with
    position = get_position()
    nearby = get_objects_in_radius(position[0], position[1], position[2], 2.0)
    
    for (i = 0; i < nearby.length; i++) {
      obj = nearby[i]
      if (obj.object != this) {
        interact_with_object(obj.object)
        break
      }
    }
  }
  
  interact_with_object(object) {
    log("Interacting with: " + object.name)
    # Custom interaction logic
  }
  
  perform_numbered_action(number) {
    log("Numbered action: " + number)
    
    switch (number) {
      case 1: set_color(1.0, 0.0, 0.0); break  # Red
      case 2: set_color(0.0, 1.0, 0.0); break  # Green
      case 3: set_color(0.0, 0.0, 1.0); break  # Blue
      case 4: set_color(1.0, 1.0, 0.0); break  # Yellow
      case 5: set_color(1.0, 0.0, 1.0); break  # Magenta
      case 6: set_color(0.0, 1.0, 1.0); break  # Cyan
      case 7: set_color(1.0, 1.0, 1.0); break  # White
      case 8: set_color(0.5, 0.5, 0.5); break  # Gray
      case 9: set_color(0.0, 0.0, 0.0); break  # Black
    }
  }
  
  toggle_menu() {
    log("Menu toggled")
    # Menu logic here
  }
  
  reset_object_transform() {
    set_position(0, 0, 0)
    set_rotation(0, 0, 0)
    set_scale(1, 1, 1)
    set_color(1.0, 1.0, 1.0)
    log("Transform reset")
  }
  
  reset_camera_view() {
    log("Camera view reset")
    # Camera reset logic
  }
  
  toggle_input_debug() {
    log("Input debug toggled")
    # Debug toggle logic
  }
  
  reset_input_state() {
    movement_vector = [0, 0, 0]
    rotation_input = [0, 0]
    input_history = []
    active_combo = []
    combo_timer = 0
    touch_start_positions = {}
  }
  
  display_input_debug() {
    # This would display input state in UI
    # For now, just log periodically
    if (get_time() % 2000 < 16) {  # Every 2 seconds
      log("Input Debug - Movement: [" + movement_vector[0] + ", " + movement_vector[1] + ", " + movement_vector[2] + "]")
      log("Input Debug - Rotation: [" + rotation_input[0] + ", " + rotation_input[1] + "]")
      log("Input Debug - Mouse: [" + get_mouse_x() + ", " + get_mouse_y() + "]")
      log("Input Debug - Gamepad Connected: " + is_gamepad_connected())
      log("Input Debug - Touch Count: " + get_touch_count())
    }
  }
  
  destroy {
    log("Complete Input Demo destroyed")
    reset_input_state()
  }
}