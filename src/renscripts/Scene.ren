script SceneManagementDemo {
  props Scene_Queries {
    search_tag: string {
      default: "demo_object",
      description: "Tag to search for in scene queries"
    }
    
    search_radius: range {
      default: 5.0,
      min: 1.0,
      max: 50.0,
      description: "Search radius for spatial queries"
    }
    
    raycast_distance: range {
      default: 20.0,
      min: 1.0,
      max: 100.0,
      description: "Maximum raycast distance"
    }
    
    enable_performance_monitor: boolean {
      default: true,
      description: "Enable scene performance monitoring"
    }
  }
  
  props Object_Management {
    auto_clone_objects: boolean {
      default: false,
      description: "Automatically clone nearby objects"
    }
    
    max_clones: range {
      default: 5.0,
      min: 1.0,
      max: 20.0,
      description: "Maximum number of clones to create"
    }
    
    clone_spacing: range {
      default: 2.0,
      min: 0.5,
      max: 10.0,
      description: "Spacing between cloned objects"
    }
    
    enable_lod: boolean {
      default: false,
      description: "Enable Level of Detail optimization"
    }
    
    lod_distances: string {
      default: "5,10,20",
      description: "LOD distances (comma-separated)"
    }
  }
  
  props Interaction {
    interaction_range: range {
      default: 3.0,
      min: 1.0,
      max: 10.0,
      description: "Range for object interaction"
    }
    
    highlight_color_r: range {
      default: 1.0,
      min: 0.0,
      max: 1.0,
      description: "Highlight red component"
    }
    
    highlight_color_g: range {
      default: 1.0,
      min: 0.0,
      max: 1.0,
      description: "Highlight green component"
    }
    
    highlight_color_b: range {
      default: 0.0,
      min: 0.0,
      max: 1.0,
      description: "Highlight blue component"
    }
  }
  
  # Scene management state
  discovered_objects = []
  tagged_objects = []
  nearby_objects = []
  cloned_objects = []
  interaction_targets = []
  highlighted_object = null
  scene_stats = {}
  performance_data = {}
  
  # Raycast state
  last_raycast_hit = null
  raycast_visualization_time = 0
  
  # LOD state
  lod_levels = []
  
  start {
    log("Scene Management Demo initialized")
    add_tag("scene_manager")
    add_tag(search_tag)
    
    # Enable performance monitoring
    if (enable_performance_monitor) {
      enable_performance_monitor()
      log("Performance monitoring enabled")
    }
    
    # Set up LOD if enabled
    if (enable_lod) {
      setup_level_of_detail()
    }
    
    # Initial scene scan
    perform_initial_scene_scan()
  }
  
  update(dt) {
    # Update scene statistics
    update_scene_statistics()
    
    # Continuous object discovery
    discover_nearby_objects()
    
    # Handle raycasting
    perform_continuous_raycast()
    
    # Object interaction system
    handle_object_interactions()
    
    # Auto-cloning system
    if (auto_clone_objects) {
      handle_auto_cloning()
    }
    
    # LOD management
    if (enable_lod) {
      update_level_of_detail()
    }
    
    # Performance monitoring
    if (enable_performance_monitor) {
      monitor_performance()
    }
    
    # Input handling for scene operations
    handle_scene_input()
    
    # Update raycast visualization timer
    if (raycast_visualization_time > 0) {
      raycast_visualization_time = raycast_visualization_time - dt
      if (raycast_visualization_time <= 0) {
        clear_raycast_visualization()
      }
    }
  }
  
  # === SCENE DISCOVERY ===
  
  perform_initial_scene_scan() {
    log("Performing initial scene scan...")
    
    # Get all scene objects
    all_meshes = get_all_meshes()
    all_lights = get_all_lights()
    all_cameras = get_all_cameras()
    
    log("Scene contains:")
    log("- Meshes: " + all_meshes.length)
    log("- Lights: " + all_lights.length)
    log("- Cameras: " + all_cameras.length)
    
    # Discover tagged objects
    tagged_objects = find_objects_by_tag(search_tag)
    log("- Objects with tag '" + search_tag + "': " + tagged_objects.length)
    
    # Store discovered objects
    discovered_objects = []
    discovered_objects.push(...all_meshes)
    discovered_objects.push(...all_lights)
    discovered_objects.push(...all_cameras)
  }
  
  discover_nearby_objects() {
    position = get_position()
    nearby_objects = get_objects_in_radius(
      position[0], position[1], position[2], 
      search_radius
    )
    
    # Process nearby objects
    for (i = 0; i < nearby_objects.length; i++) {
      obj_data = nearby_objects[i]
      obj = obj_data.object
      distance = obj_data.distance
      
      # Skip self
      if (obj == this.babylonObject) continue
      
      # Add interaction potential
      if (distance <= interaction_range) {
        if (interaction_targets.indexOf(obj) == -1) {
          interaction_targets.push(obj)
          log("New interaction target: " + obj.name)
        }
      } else {
        # Remove from interaction targets if too far
        index = interaction_targets.indexOf(obj)
        if (index > -1) {
          interaction_targets.splice(index, 1)
          log("Lost interaction target: " + obj.name)
        }
      }
    }
  }
  
  # === RAYCASTING SYSTEM ===
  
  perform_continuous_raycast() {
    # Raycast forward from object
    position = get_position()
    rotation = get_rotation()
    
    # Calculate forward direction
    forward_x = sin(rotation[1])
    forward_y = -sin(rotation[0])
    forward_z = cos(rotation[1])
    
    # Perform raycast
    hit = raycast(
      position[0], position[1], position[2],
      forward_x, forward_y, forward_z,
      raycast_distance
    )
    
    if (hit.hit) {
      if (last_raycast_hit != hit.object) {
        last_raycast_hit = hit.object
        log("Raycast hit: " + hit.object.name + " at distance " + hit.distance)
        
        # Visualize hit
        set_emissive_color(0.0, 1.0, 0.0)
        raycast_visualization_time = 500  # ms
        
        # Highlight hit object
        highlight_object(hit.object)
      }
    } else {
      if (last_raycast_hit) {
        last_raycast_hit = null
        clear_raycast_visualization()
        clear_object_highlight()
      }
    }
    
    # Multi-raycast for complex detection
    if (is_key_pressed("m")) {
      multi_hits = multi_raycast(
        position[0], position[1], position[2],
        forward_x, forward_y, forward_z,
        raycast_distance
      )
      
      log("Multi-raycast found " + multi_hits.length + " objects")
      
      for (i = 0; i < multi_hits.length; i++) {
        hit_data = multi_hits[i]
        if (hit_data.hit) {
          log("- Hit: " + hit_data.object.name + " at " + hit_data.distance)
        }
      }
    }
  }
  
  clear_raycast_visualization() {
    set_emissive_color(0.0, 0.0, 0.0)
  }
  
  # === OBJECT HIGHLIGHTING ===
  
  highlight_object(object) {
    # Clear previous highlight
    clear_object_highlight()
    
    highlighted_object = object
    
    # Apply highlight effect (this would need to modify the object's material)
    # For demo purposes, we'll just log
    log("Highlighting object: " + object.name)
  }
  
  clear_object_highlight() {
    if (highlighted_object) {
      log("Clearing highlight from: " + highlighted_object.name)
      highlighted_object = null
    }
  }
  
  # === OBJECT INTERACTION ===
  
  handle_object_interactions() {
    # Interaction with closest target
    if (interaction_targets.length > 0 && is_key_pressed("e")) {
      closest_target = get_closest_interaction_target()
      if (closest_target) {
        interact_with_object(closest_target)
      }
    }
    
    # Pick objects with mouse
    if (is_left_mouse_button_pressed()) {
      mouse_pos = get_mouse_position()
      picked = pick_object(mouse_pos[0], mouse_pos[1])
      
      if (picked) {
        log("Picked object: " + picked.name)
        interact_with_object(picked)
        
        # Multi-pick for overlapping objects
        all_picked = pick_objects(mouse_pos[0], mouse_pos[1])
        if (all_picked.length > 1) {
          log("Multiple objects at cursor: " + all_picked.length)
        }
      }
    }
  }
  
  get_closest_interaction_target() {
    if (interaction_targets.length == 0) return null
    
    position = get_position()
    closest = null
    closest_distance = Infinity
    
    for (i = 0; i < interaction_targets.length; i++) {
      target = interaction_targets[i]
      
      # Calculate distance
      target_pos = target.position || [0, 0, 0]
      dist = distance(
        position[0], position[1], position[2],
        target_pos[0], target_pos[1], target_pos[2]
      )
      
      if (dist < closest_distance) {
        closest_distance = dist
        closest = target
      }
    }
    
    return closest
  }
  
  interact_with_object(object) {
    log("Interacting with: " + object.name)
    
    # Get object metadata
    if (has_metadata("interaction_type")) {
      interaction_type = get_metadata("interaction_type")
      log("Interaction type: " + interaction_type)
    }
    
    # Bounding box information
    bounding_info = get_bounding_info()
    if (bounding_info) {
      log("Object bounds: " + 
          "min[" + bounding_info.min[0] + "," + bounding_info.min[1] + "," + bounding_info.min[2] + "] " +
          "max[" + bounding_info.max[0] + "," + bounding_info.max[1] + "," + bounding_info.max[2] + "]")
    }
    
    # Check if object intersects with us
    if (intersects_mesh(object)) {
      log("Objects are intersecting!")
    }
    
    # Set interaction metadata
    set_metadata("last_interaction", get_time())
    set_metadata("interacted_with", object.name)
  }
  
  # === OBJECT CLONING ===
  
  handle_auto_cloning() {
    if (cloned_objects.length >= max_clones) return
    
    # Clone nearby objects
    for (i = 0; i < nearby_objects.length && cloned_objects.length < max_clones; i++) {
      obj_data = nearby_objects[i]
      original = obj_data.object
      
      # Skip if already cloned or is self
      if (is_already_cloned(original) || original == this.babylonObject) continue
      
      # Clone the object
      cloned_name = original.name + "_clone_" + cloned_objects.length
      cloned = clone_object(cloned_name, null)
      
      if (cloned) {
        # Position clone with spacing
        clone_offset_x = (cloned_objects.length % 3) * clone_spacing
        clone_offset_z = floor(cloned_objects.length / 3) * clone_spacing
        
        original_pos = original.position || [0, 0, 0]
        cloned.position.set(
          original_pos[0] + clone_offset_x,
          original_pos[1],
          original_pos[2] + clone_offset_z
        )
        
        cloned_objects.push({
          original: original,
          clone: cloned
        })
        
        log("Cloned object: " + original.name + " -> " + cloned_name)
        
        # Add metadata to track cloning
        cloned.metadata = cloned.metadata || {}
        cloned.metadata.is_clone = true
        cloned.metadata.original_name = original.name
      }
    }
  }
  
  is_already_cloned(object) {
    for (i = 0; i < cloned_objects.length; i++) {
      if (cloned_objects[i].original == object) {
        return true
      }
    }
    return false
  }
  
  # === LEVEL OF DETAIL ===
  
  setup_level_of_detail() {
    # Parse LOD distances
    distance_strings = lod_distances.split(",")
    lod_levels = []
    
    for (i = 0; i < distance_strings.length; i++) {
      distance = parseFloat(distance_strings[i].trim())
      if (!isNaN(distance)) {
        lod_levels.push(distance)
      }
    }
    
    log("LOD levels configured: " + lod_levels.length)
    
    # Create LOD meshes (simplified versions)
    for (i = 0; i < lod_levels.length; i++) {
      distance = lod_levels[i]
      
      # Create simplified mesh for this LOD level
      # This is a placeholder - actual LOD meshes would be created differently
      lod_mesh = clone_object("lod_" + i, null)
      if (lod_mesh) {
        # Simplify the LOD mesh
        # lod_mesh.simplify(...)  # This would need actual mesh simplification
        
        add_lod_level(distance, lod_mesh)
        log("Added LOD level at distance: " + distance)
      }
    }
  }
  
  update_level_of_detail() {
    # LOD is typically handled automatically by Babylon.js
    # This is where we could add custom LOD logic
    
    # Check camera distance for manual LOD switching
    if (scene.activeCamera) {
      camera_pos = scene.activeCamera.position
      object_pos = get_position()
      
      camera_distance = distance(
        camera_pos.x, camera_pos.y, camera_pos.z,
        object_pos[0], object_pos[1], object_pos[2]
      )
      
      # Log current LOD level based on distance
      current_lod = -1
      for (i = 0; i < lod_levels.length; i++) {
        if (camera_distance > lod_levels[i]) {
          current_lod = i
        }
      }
      
      # Store current LOD in metadata
      set_metadata("current_lod", current_lod)
    }
  }
  
  # === SPATIAL QUERIES ===
  
  perform_spatial_queries() {
    position = get_position()
    
    # Box query
    box_objects = get_objects_in_box(
      position[0] - 2, position[1] - 2, position[2] - 2,
      position[0] + 2, position[1] + 2, position[2] + 2
    )
    log("Objects in box: " + box_objects.length)
    
    # Find closest object with specific tag
    closest_tagged = get_closest_object(position[0], position[1], position[2], search_tag)
    if (closest_tagged) {
      log("Closest tagged object: " + closest_tagged.object.name + " at " + closest_tagged.distance)
    }
    
    # Point intersection tests
    test_points = [
      [position[0] + 1, position[1], position[2]],
      [position[0] - 1, position[1], position[2]],
      [position[0], position[1] + 1, position[2]],
      [position[0], position[1] - 1, position[2]]
    ]
    
    for (i = 0; i < test_points.length; i++) {
      point = test_points[i]
      intersects = intersects_point(point[0], point[1], point[2])
      if (intersects) {
        log("Point intersection detected at: " + point[0] + "," + point[1] + "," + point[2])
      }
    }
  }
  
  # === SCENE STATISTICS ===
  
  update_scene_statistics() {
    scene_stats = get_scene_info()
    
    # Store in metadata for access by other scripts
    set_metadata("scene_stats", scene_stats)
  }
  
  # === PERFORMANCE MONITORING ===
  
  monitor_performance() {
    performance_data = get_performance_data()
    
    if (performance_data && performance_data.averageFrameTime) {
      # Log performance issues
      if (performance_data.averageFrameTime > 20) {  # Above 20ms = below 50 FPS
        log("Performance warning: Frame time " + performance_data.averageFrameTime + "ms")
      }
      
      # Store performance data
      set_metadata("performance", performance_data)
    }
  }
  
  # === INPUT HANDLING ===
  
  handle_scene_input() {
    # Scene query hotkeys
    if (is_key_pressed("1")) {
      perform_spatial_queries()
    }
    
    if (is_key_pressed("2")) {
      log("=== SCENE STATISTICS ===")
      if (scene_stats.meshCount !== undefined) {
        log("Meshes: " + scene_stats.meshCount)
        log("Lights: " + scene_stats.lightCount)
        log("Cameras: " + scene_stats.cameraCount)
        log("Materials: " + scene_stats.materialCount)
        log("Textures: " + scene_stats.textureCount)
        log("Total Vertices: " + scene_stats.totalVertices)
        log("Total Indices: " + scene_stats.totalIndices)
        log("Draw Calls: " + scene_stats.drawCalls)
        log("Frame Rate: " + scene_stats.frameRate)
      }
    }
    
    if (is_key_pressed("3")) {
      log("=== PERFORMANCE DATA ===")
      if (performance_data.averageFrameTime !== undefined) {
        log("Average Frame Time: " + performance_data.averageFrameTime + "ms")
        log("Instantaneous Frame Time: " + performance_data.instantaneousFrameTime + "ms")
        log("Frame Time Variance: " + performance_data.averageFrameTimeVariance)
        log("Monitor Enabled: " + performance_data.isEnabled)
      }
    }
    
    if (is_key_pressed("4")) {
      log("=== DISCOVERED OBJECTS ===")
      for (i = 0; i < Math.min(10, discovered_objects.length); i++) {
        obj = discovered_objects[i]
        log("- " + obj.name + " (type: " + obj.constructor.name + ")")
      }
      if (discovered_objects.length > 10) {
        log("... and " + (discovered_objects.length - 10) + " more")
      }
    }
    
    if (is_key_pressed("5")) {
      log("=== NEARBY OBJECTS ===")
      for (i = 0; i < nearby_objects.length; i++) {
        obj_data = nearby_objects[i]
        log("- " + obj_data.object.name + " at distance " + obj_data.distance.toFixed(2))
      }
    }
    
    if (is_key_pressed("6")) {
      log("=== INTERACTION TARGETS ===")
      for (i = 0; i < interaction_targets.length; i++) {
        target = interaction_targets[i]
        log("- " + target.name)
      }
    }
    
    # Object disposal
    if (is_key_pressed("delete") && highlighted_object) {
      log("Disposing highlighted object: " + highlighted_object.name)
      dispose_object(highlighted_object)
      highlighted_object = null
    }
    
    # Camera view testing
    if (is_key_pressed("v")) {
      in_view = is_in_camera_view()
      log("Object in camera view: " + in_view)
    }
    
    # Occlusion query toggle
    if (is_key_pressed("o")) {
      set_occlusion_query(true)
      log("Occlusion query enabled")
    }
  }
  
  # === CLEANUP ===
  
  cleanup_cloned_objects() {
    for (i = 0; i < cloned_objects.length; i++) {
      clone_data = cloned_objects[i]
      if (clone_data.clone) {
        dispose_object(clone_data.clone)
      }
    }
    cloned_objects = []
    log("Cleaned up cloned objects")
  }
  
  destroy {
    log("Scene Management Demo destroyed")
    
    # Disable performance monitoring
    if (enable_performance_monitor) {
      disable_performance_monitor()
    }
    
    # Clean up cloned objects
    cleanup_cloned_objects()
    
    # Clear object references
    discovered_objects = []
    tagged_objects = []
    nearby_objects = []
    interaction_targets = []
    highlighted_object = null
    
    # Clear LOD levels
    for (i = 0; i < lod_levels.length; i++) {
      # Remove LOD levels would go here
      # remove_lod_level(...)
    }
    lod_levels = []
  }
}