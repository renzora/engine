// Auto-generated by Material Blueprint
// DO NOT EDIT - changes will be overwritten

#import bevy_pbr::{
    pbr_functions::pbr,
    pbr_types::PbrInput,
    pbr_types::pbr_input_new,
    mesh_view_bindings::view,
    mesh_view_bindings::globals,
    forward_io::VertexOutput,
}



@fragment
fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
    // Access vertex data from Bevy's VertexOutput
    // in.position - clip space position
    // in.world_position - world space position
    // in.world_normal - world space normal
    // in.uv - texture coordinates
    let rgb_0 = vec4<f32>(0.000000, 0.000000, 0.000000, 1.000000).rgb;
    let rgb_1 = vec4<f32>(0.349020, 0.458824, 0.725490, 1.000000).rgb;
    let checker_2 = abs(fract(in.uv.x * 3.000000) - 0.5) + abs(fract(in.uv.y * 3.000000) - 0.5);
    let checker_final_3 = step(0.5, fract(floor(in.uv.x * 3.000000) + floor(in.uv.y * 3.000000)));
    let lerp_4 = mix(vec4<f32>(0.000000, 0.000000, 0.000000, 1.000000), vec4<f32>(0.349020, 0.458824, 0.725490, 1.000000), checker_final_3);

    // PBR Output
    var pbr_input: PbrInput = pbr_input_new();
    pbr_input.material.base_color = lerp_4;
    pbr_input.material.metallic = 0.000000;
    pbr_input.material.perceptual_roughness = 0.500000;
    pbr_input.material.emissive = vec4<f32>(0.000000, 0.000000, 0.000000, 1.000000).rgb * vec4<f32>(0.000000, 0.000000, 0.000000, 1.000000).a;
    pbr_input.occlusion = vec3<f32>(1.000000);
    pbr_input.world_normal = normalize(in.world_normal);
    pbr_input.world_position = vec4<f32>(in.world_position, 1.0);
    pbr_input.frag_coord = in.position;

    var color = pbr(pbr_input);
    color.a = 1.000000;
    return color;
}
