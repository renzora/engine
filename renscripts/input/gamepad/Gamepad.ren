
script GamepadController {
  
  # Track position manually to work around RenScript limitations
  pos_x = 0.0
  pos_y = 2.0
  pos_z = 0.0
  rot_y = 0.0
  
  # Movement smoothing
  velocity_x = 0.0
  velocity_z = 0.0
  is_moving = 0.0
  
  # Jump mechanics
  grounded = 1.0
  jump_velocity = 0.0
  
  start {
    addTag("gamepad_controlled")
    # Initialize position
    setPosition(pos_x, pos_y, pos_z)
    setRotation(0.0, rot_y, 0.0)
    log("360° Gamepad Controller initialized")
  }
  
  update() {
    # Only process input if enabled
    enabled_num = 0.0
    enabled_num = enabled_num + 1.0 * enabled
    
    # Get gamepad input
    gamepad_idx = floor(gamepad_index)
    
    # Get left stick input with deadzone
    stick_x = leftX(gamepad_idx) * enabled_num
    stick_y = leftY(gamepad_idx) * enabled_num
    
    # Apply circular deadzone to prevent drift
    deadzone = 0.15
    stick_magnitude = sqrt(stick_x * stick_x + stick_y * stick_y)
    
    # Calculate movement direction
    movement_x = 0.0
    movement_z = 0.0
    is_moving = 0.0
    
    if (stick_magnitude > deadzone) {
      # Normalize input and apply scaled magnitude
      normalized_x = stick_x / stick_magnitude
      normalized_z = stick_y / stick_magnitude * -1.0  # Invert Y for forward
      
      # Scale magnitude beyond deadzone (0 to 1)
      adjusted_magnitude = (stick_magnitude - deadzone) / (1.0 - deadzone)
      adjusted_magnitude = clamp(adjusted_magnitude, 0.0, 1.0)
      
      movement_x = normalized_x * adjusted_magnitude
      movement_z = normalized_z * adjusted_magnitude
      is_moving = 1.0
    }
    
    # === SMOOTH MOVEMENT ===
    # Apply velocity smoothing for natural acceleration/deceleration
    accel = 8.0   # Acceleration rate
    decel = 10.0  # Deceleration rate
    
    if (is_moving > 0.0) {
      # Accelerate towards target velocity
      target_vel_x = movement_x * speed
      target_vel_z = movement_z * speed
      
      velocity_x = lerp(velocity_x, target_vel_x, accel * time())
      velocity_z = lerp(velocity_z, target_vel_z, accel * time())
    } else {
      # Decelerate to zero
      velocity_x = lerp(velocity_x, 0.0, decel * time())
      velocity_z = lerp(velocity_z, 0.0, decel * time())
    }
    
    # === CHARACTER ROTATION ===
    # Character faces movement direction when moving
    if (is_moving > 0.0) {
      # Calculate target rotation from movement direction
      target_rotation = atan2(movement_x, movement_z)
      
      # Smooth rotation towards target
      rot_speed = rotation_speed * 4.0  # Responsive rotation
      
      # Calculate shortest rotation path
      angle_diff = target_rotation - rot_y
      
      # Normalize angle difference to [-π, π]
      while (angle_diff > 3.14159) {
        angle_diff = angle_diff - 6.28318
      }
      while (angle_diff < -3.14159) {
        angle_diff = angle_diff + 6.28318
      }
      
      rot_y = rot_y + angle_diff * rot_speed * time()
    }
    
    # === JUMP MECHANICS ===
    # A button for jump
    button_a = button(0, gamepad_idx)
    if (button_a > 0.0 && grounded > 0.0) {
      jump_velocity = 12.0  # Jump strength
      grounded = 0.0
      log("Jump!")
    }
    
    # Apply gravity
    gravity = -20.0
    jump_velocity = jump_velocity + gravity * time()
    
    # === SPEED MODIFIERS ===
    # Right trigger: Sprint (hold for faster movement)
    right_trigger = rightTrigger(gamepad_idx)
    sprint_mult = 1.0 + right_trigger * 1.5  # Up to 2.5x speed
    
    # Left trigger: Walk (hold for slower, precise movement)
    left_trigger = leftTrigger(gamepad_idx)
    walk_mult = 1.0 - left_trigger * 0.6   # Down to 40% speed
    
    # Combine speed modifiers
    final_speed_mult = sprint_mult * walk_mult
    
    # Apply movement to position
    pos_x = pos_x + velocity_x * time() * final_speed_mult
    pos_z = pos_z + velocity_z * time() * final_speed_mult
    
    # Apply jump and gravity
    pos_y = pos_y + jump_velocity * time()
    
    # Ground collision (simple Y = 0 ground)
    if (pos_y <= 0.0) {
      pos_y = 0.0
      jump_velocity = 0.0
      grounded = 1.0
    }
    
    # === CAMERA/MANUAL ROTATION ===
    # Right stick for manual rotation (overrides auto-rotation when used)
    camera_x = rightX(gamepad_idx) * enabled_num
    camera_magnitude = abs(camera_x)
    
    if (camera_magnitude > deadzone) {
      # Manual rotation with right stick
      manual_rot = camera_x * rotation_speed * time() * 2.0
      rot_y = rot_y + manual_rot
    }
    
    # === UTILITY BUTTONS ===
    # Y button: Reset to origin
    button_y = button(3, gamepad_idx)
    if (button_y > 0.0) {
      pos_x = 0.0
      pos_y = 2.0
      pos_z = 0.0
      rot_y = 0.0
      velocity_x = 0.0
      velocity_z = 0.0
      jump_velocity = 0.0
      grounded = 1.0
      log("Position reset to origin")
    }
    
    # B button: Emergency stop
    button_b = button(1, gamepad_idx)
    if (button_b > 0.0) {
      velocity_x = 0.0
      velocity_z = 0.0
      jump_velocity = 0.0
    }
    
    # Apply transforms
    setPosition(pos_x, pos_y, pos_z)
    setRotation(0.0, rot_y, 0.0)
  }
  
  destroy {
    log("360° Gamepad Controller destroyed")
    removeTag("gamepad_controlled")
  }
}